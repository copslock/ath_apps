<chapter id='support-functions'>
	<title>
		Support Function Reference
		</title>
	<section id="support-intro" >
		<title>
			Introduction
			</title>
		<para>
			The Intellon <application>Linux Toolkit</application> includes many functions that have application outside the <application>Linux Toolkit</application>. They are distributed with the toolkit but may also appear in other Intellon applications or third party packages. Consequently, we describe them separately and store them in separate folders.
			</para>
		</section>
	<section id="support-command">
		<title>
			Command Line Functions
			</title>
		<para>
			Command line functions are used by all toolkit programs. They are generic functions but we include them in a special section because they collectively co-operate to convert command line options and arguments into appropriate binary representations and provide concise but meaningful feedback when that is not possible.
			</para>
	<section id="support-alert">
		<title>
			alert
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>alert</function></funcdef>
    				<paramdef>char const * <parameter>format</parameter></paramdef>
    				<paramdef><parameter>...</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			<para>
				This function is similar to function <function>printf</function> but messages are prefixed with the program name and appear on <constant>stderr</constant> instead of <constant>stdout</constant>. It is equivalent to calling function <link linkend='support-error'>error</link> with argument <varname>exitcode</varname> set to <constant>0</constant> and argument <varname>errno</varname> set to <constant>0</constant>. A typical use is to print progress messages. The function is declared in <ulink url='error.h.html'>error.h</ulink> and defined in <ulink url='alert.c.html'>alert.c</ulink>.
				</para>
		</section>
	<section id="support-assist">
		<title>
			assist
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>void <function>assist</function></funcdef>
  				<paramdef>char const * <parameter>name</parameter></paramdef>
   				<paramdef>char const * <parameter>type</parameter></paramdef>
  				<paramdef>const struct _code_ <parameter>list</parameter> []</paramdef>
    				<paramdef>size_t <parameter>size</parameter></paramdef>
				<paramdef>FILE * <parameter>fp</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Show why a symbolic <varname>name</varname> was rejected by function <link linkend='support-lookup'>lookup</link> or similar functions. Argument <varname>type</varname> contains a title for the class of names stored in <varname>list</varname>. This function prints an error message on file stream <constant>fp</constant> showing the program name,  the <varname>type</varname> string,  the symbolic <varname>name</varname> and all names stored in the <varname>list</varname>. The <constant>_code_</constant> structure is declared in <ulink url='types.h.html'>types.h</ulink>. The function is declared in <ulink url='symbol.h.html'>symbol.h</ulink> and defined in <ulink url='assist.c.html'>assist.c</ulink>. Function <link linkend='support-expect'>expect</link> is used to print list names.
			</para>
		</section>
	<section id="support-basespec">
		<title>
			basespec
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>uint64_t <function>basespec</function></funcdef>
    				<paramdef>char const * <parameter>string</parameter></paramdef>
   				<paramdef>unsigned <parameter>base</parameter></paramdef>
   				<paramdef>unsigned <parameter>size</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Return the unsigned integer equivalent of a numeric <varname>string</varname>. Print an error message on <varname>stderr</varname> and exit the program with status <constant>1</constant> if a syntax error occurs or the result exceeds the capacity of the requested integer <varname>size</varname> in bytes. If <varname>base</varname> is <constant>0</constant>,  numeric values may be expressed in decimal, hexadecimal or binary notation where hexadecimal values start with <constant>"0x"</constant> and binary values start with <constant>"0b"</constant>. When <varname>base</varname> is non-zero, the notation in <varname>string</varname> must conform to the corresponding number base rules. Applications should cast the return value to the appropriate data type prevent loss-of-data compiler warnings. This function is typically used to convert and length-check integers entered as command line arguments. The function is declared in <ulink url='number.h.html'>number.h</ulink> and defined in <ulink url='basespec.c.html'>basespec.c</ulink>.
			</para>
		<para>
			Like function <link linkend='support-uintspec'>uintspec</link>,  this function both converts and range checks numeric string values,  but the minimum and maximum value are implicit in the <varname>size</varname> of the integer. The minimum value is always <constant>0</constant> and the maximum value can be computed by  <constant>((1 &lt;&lt; size &lt;&lt; 3) - 1)</constant>.
			</para>
		</section>
	<section id="support-bytespec">
		<title>
			bytespec
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>bytespec</function></funcdef>
    				<paramdef>char const * <parameter>string</parameter></paramdef>
   				<paramdef>void  * <parameter>memory</parameter></paramdef>
   				<paramdef>size_t <parameter>extent</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Encode a <varname>memory</varname> region with the binary equivalent of a fixed-length hexadecimal string. Print an error message on stderr and exit the program with status <constant>1</constant> if a syntax error occurs or the number of octets does not equal  <varname>extent</varname>. Hexadecimal octets may be separated by colons for readability but colons are not required. Empty octets are illegal. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='bytespec.c.html'>bytespec.c</ulink>.
			</para>
		<para>
			This function is typically used to enter fixed-length data, like hardware addresses and encryption keys, on the command line. 
			</para>
		</section>
	<section id="support-checkfilename">
		<title>
			checkfilename
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>bool <function>checkfilename</function></funcdef>
    				<paramdef>char const * <parameter>filename</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			<para>
				Return logical <constant>true</constant> if the <varname>filename</varname> argument contains only letters, digits, slashes, periods, underscores and hyphens. This function can be used to detect cases where a user accidentally entered an Ethernet address in place of a filename on the command line. Ethernet address strings are, as it happens, also valid filenames. The function is declared in <ulink url='files.h.html'>files.h</ulink> and defined in <ulink url='checkfilename.c.html'>checkfilename.c</ulink>.
				</para>
		</section>
	<section id="support-dataspec">
		<title>
			dataspec
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>dataspec</function></funcdef>
    				<paramdef>char const * <parameter>string</parameter></paramdef>
   				<paramdef>void  * <parameter>memory</parameter></paramdef>
   				<paramdef>size_t <parameter>extent</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Encode a <varname>memory</varname> region with the binary equivalent of a variable-length hexadecimal string. Print an error message on stderr and exit the program with the status <constant>1</constant> if a syntax error occurs or the number of octets exceeds <varname>extent</varname>. The number of octets may, however, be less than <constant>extent</constant>. Unlike function <link linkend='support-bytespec'>bytespec</link>, hexadecimal octets may not be separated by colons. This function is typically used to enter variable-length data from the command line. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='dataspec.c.html'>dataspec.c</ulink>.
			</para>
		</section>
	<section id="support-error">
		<title>
			error
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>error</function></funcdef>
    				<paramdef>int<parameter>exitcode</parameter></paramdef>
    				<paramdef>errno_t <parameter>number</parameter></paramdef>
   				<paramdef>char const * <parameter>format</parameter></paramdef>
   				<paramdef><parameter>...</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			This function works like printf except that printed messages appear on <constant>stderr</constant> and are prefixed with the program name and error information. If argument <varname>errno</varname> is non-zero then messages are prefixed with the system error description. If argument <varname>exitcode</varname> is non-zero then function <varname>error</varname> exits the program with value <varname>exitcode</varname> after printing the message and does not return to the caller. The function is declared in <ulink url='error.h.html'>error.h</ulink> and defined in <ulink url='error.c.html'>error.c</ulink>.
			</para>
		<para>
			This function is used to print informative error messages on the console and prevent program execution from proceeding when input is invalid or some error condition exists.
			</para>
		</section>
	<section id="support-expect">
		<title>
			expect
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>void <function>expect</function></funcdef>
  				<paramdef>const struct _code_ <parameter>list</parameter> []</paramdef>
    				<paramdef>size_t <parameter>size</parameter></paramdef>
     				<paramdef>FILE * <parameter>fp</parameter></paramdef>
 				</funcprototype>
			</funcsynopsis>
		<para>
			Display all names in argument <varname>list</varname> on file stream <varname>fp</varname>. This function is called by runction <link linkend='support-assist'>assist</link> to print the list of symbolic names but other function may have use for it. The <constant>_code_</constant> structure is declared in <ulink url='types.h.html'>types.h</ulink>. The function is declared in <ulink url='symbol.h.html'>symbol.h</ulink> and defined in <ulink url='expect.c.html'>expect.c</ulink>.
			</para>
		</section>
	<section id="support-getoptv">
		<title>
			getoptv
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>int <function>getoptv</function></funcdef>
    				<paramdef>int <parameter>argc</parameter></paramdef>
    				<paramdef>char const * <parameter>argv</parameter> []</paramdef>
   				<paramdef>char const * <parameter>optv</parameter> []</paramdef>
 				</funcprototype>
			</funcsynopsis>
		<para>
			A custom version of the <acronym>POSIX</acronym> function <function>getopt</function>. It supports standard global variables <varname>optind</varname>, <varname>opterr</varname>, <varname>optopt</varname> and <varname>optarg</varname> and the non-standard variable <varname>optmin</varname>. It extracts the program name from <varname>argv[0]</varname> and sets global string pointer <varname>program_name</varname> for use by functions <function>alert</function>, <function>error</function> and others. Options <userinput>-?</userinput> and <userinput>--help</userinput> both display program information on <constant>stdout</constant>. Options <userinput>-!</userinput> and <userinput>--version</userinput> both display program version information on <constant>stdout</constant>. String vector <varname>optv</varname> includes both the standard argument <varname>optstring</varname> and usage text found in many programs. The function is declared in <ulink url='getoptv.h.html'>getoptv.h</ulink> and defined in <ulink url='getoptv.c.html'>getoptv.c</ulink>.
			</para>
		</section>
	<section id="support-ipv4spec">
		<title>
			ipv4spec
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>size_t <function>ipv4spec</function></funcdef>
    				<paramdef>char const * <parameter>string</parameter></paramdef>
   				<paramdef>void  * <parameter>memory</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Encode a 4-byte <varname>memory</varname> region with an IPv4 dotted-decimal <varname>string</varname> and return the number of bytes encoded. Terminate the program with an error message and exitcode of <constant>1</constant> on conversion error. The value returned by this function is always <constant>4</constant> and memory is always encoded in network byte order. This function is typically used to convert IPv4 strings entered as command line arguments. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='ipv4spec.c.html'>ipv4spec.c</ulink>.
			</para>
		<para>
			Dotted-decimal format consists of decimal values in the range 0 through 255. Each value represents one octet or 8-bit value. IPv4 addresses require 4 such values separated by one decimal point. This function permits empty octets and leading zeros within octets. For example,  <quote>...</quote> is equivalent to <quote>0.0.0.0</quote> and <quote>127.0.000.001</quote> is equivalent to <quote>127.0.0.1</quote>. The second example will encode memory as follows <constant>{ 0x7F, 0x00, 0x00, 0x01 }</constant> which is in network byte order, or big endian.
			</para>
		</section>
	<section id="support-ipv6spec">
		<title>
			ipv6spec
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>size_t <function>ipv6spec</function></funcdef>
    				<paramdef>char const * <parameter>string</parameter></paramdef>
   				<paramdef>void  * <parameter>memory</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Encode a 16-byte <varname>memory</varname> region with an IPv6 colon-separated hexadecimal quartet <varname>string</varname> and return the number of bytes encoded. Terminate the program with an error message and exitcode of <constant>1</constant> on conversion error. The value returned by this function is always <constant>16</constant> and memory is always encoded in network byte order. This function is typically used to convert IPv6 strings entered as command line arguments. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='ipv6spec.c.html'>ipv6spec.c</ulink>.
			</para>
		<para>
			Colon-separated hexadecimal quartet notation consists of hexadecimal values in the range 0 through FFFF. Each value represents a quartet or a 32-bit value. IPv6 addresses require 8 quartets separated by one colon. By convention, an empty quartet expands with enough zeros to right-justify the remainder of the address. This function permits multiple empty quartets and leading zeros within quartets. When multiple empty quartets appear, only the right-most occurance expands to zeros. For example,  <quote>AA12::BB34::CC56::DD78</quote> is equivalent to <quote>AA12:0000:BB34:0000:CC56:0000:0000:DD78</quote> because only the right-most empty field expands. This will encode memory as follows <constant>{ 0xAA, 0x12, 0x00, 0x00, 0xBB, 0x34, 0x00, 0x00, 0xCC, 0x56, 0x00, 0x00, 0x00, 0x00, 0xDD, 0x78 }</constant> which is in network byte order, or big-endian.
			</para>
		</section>
	<section id="support-lookup">
		<title>
			lookup
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>signed <function>lookup</function></funcdef>
  				<paramdef>char const * <parameter>name</parameter></paramdef>
   				<paramdef>const struct _code_ <parameter>list</parameter> []</paramdef>
    				<paramdef>size_t <parameter>size</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Lookup a symbolic <varname>name</varname> in a <varname>list</varname> and return an associated integer or <constant>-1</constant> if the <varname>name</varname> does not appear in the <varname>list</varname>. A typical use is the translation of symbolic command line arguments to integer codes. For example, some Toolkit programs assign symbolic names to field codes so that users can enter names instead of numbers. This approach becomes more useful as the number of permitted codes increases. The <constant>_code_</constant> structure is declared in <ulink url='types.h.html'>types.h</ulink>. The function is declared in <ulink url='symbol.h.html'>symbol.h</ulink> and defined in <ulink url='lookup.c.html'>lookup.c</ulink>.
			</para>
		<para>
			This function offers two benefits: 1) multiple symbols can translate to one code and 2) names can be changed or new names added without affecting program logic. This function is similar to but different from function <link linkend='support-synonym'>synonym</link> which returns a character string instead of an integer. 
			</para>
		</section>
	<section id="support-putoptv">
		<title>
			putoptv
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>putoptv</function></funcdef>
    				<paramdef>char const * <parameter>optv</parameter> []</paramdef>
 				</funcprototype>
			</funcsynopsis>
		<para>
			Print program information on <constant>stdout</constant>. Program information is stored in string vector <varname>optv</varname>. String indexes are defined in file <filename>putoptv.h</filename>. String <varname>optv[0]</varname> is the <acronym>POSIX</acronym> standard argument <varname>optstring</varname>. This function is called by function <function>getoptv</function> whenever option <userinput>-?</userinput> or <userinput>--help</userinput> is detected on the command line. There is virtually no need to call this function directly. The function is declared in <ulink url='putoptv.h.html'>putoptv.h</ulink> and defined in <ulink url='putoptv.c.html'>putoptv.c</ulink>.
			</para>
		</section>
	<section id="support-synonym">
		<title>
			synonym
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>char const * <function>synonym</function></funcdef>
    				<paramdef>char const * <parameter>string</parameter></paramdef>
    				<paramdef>const struct _term_ <parameter>list</parameter> []</paramdef>
    				<paramdef>size_t <parameter>size</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Lookup a symbolic <varname>name</varname> in a <varname>list</varname> and return an associated string or the original <varname>string</varname> if the <varname>name</varname> does not appear in the <varname>list</varname>. A typical use is the translation of symbolic command line arguments to their equivalent numeric strings before encoding them. For example, many Toolkit programs convert the command line argument <quote>local</quote> to <quote>00:B0:52:00:00:01</quote> before encoding the device MAC address. The <constant>_term_</constant> structure is declared in <ulink url='types.h.html'>types.h</ulink>. The function is declared in <ulink url='symbol.h.html'>symbol.h</ulink> and defined in <ulink url='synonym.c.html'>synonym.c</ulink>.
			</para>
		<para>
			This function is similar to but different from function <link linkend='support-lookup'>lookup</link> which returns an integer instead of a character string.
			</para>
		</section>
	<section id="support-uintspec">
		<title>
			uintspec
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>uint64_t <function>uintspec</function></funcdef>
    				<paramdef>char const * <parameter>string</parameter></paramdef>
   				<paramdef>uint64_t <parameter>minimum</parameter></paramdef>
   				<paramdef>uint64_t <parameter>maximum</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Return the unsigned integer equivalent of a numeric <varname>string</varname>. Print an error message on <varname>stderr</varname> and exit the program with the value <constant>1</constant> when a syntax error occurs or the result exceeds the specified <varname>minimum</varname> or <varname>maximum</varname> value. Numeric values may be expressed in decimal, hexadecimal or binary notation where hexadecimal values start with <constant>"0x"</constant> and binary values start with <constant>"0b"</constant>. Applications should cast the return value to the appropriate data type to avoid loss-of-data warnings on some compilers. This function is typically used to convert and range-check integer values entered as command-line arguments. The function is declared in <ulink url='number.h.html'>number.h</ulink> and defined in <ulink url='uintspec.c.html'>uintspec.c</ulink>.
			</para>
		</section>
	<section id="support-version">
		<title>
			version
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>version</function></funcdef>
   				<void/>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Print package and program version information on <constant>stdout</constant>. This function is called by function <function>getoptv</function> whenever option <userinput>-!</userinput> or <userinput>--version</userinput> is detected on the command line. There is no need to call this function directly. The function is declared in <ulink url='version.h.html'>version.h</ulink> and defined in <ulink url='version.c.html'>version.c</ulink>. Constants <constant>PACKAGE</constant> and <constant>VERSION</constant> define the information that is displayed. They are defined in file <ulink url="version.h.html">version.h</ulink> and must be maintained by developers. 
			</para>
		</section>
		</section>
	<section id="support-ethernet">
		<title>
			Ethernet Functions
			</title>
		<para>
			The Intellon Linux Toolkit supports raw Ethernet I/O on several popular operating systems, including <productname>Linux</productname>,  <productname>Mac OS X</productname> and Microsoft <productname>Windows</productname>. Other operating systems will probably be added over time. These functions are found in the <filename>ether</filename> folder.
			</para>
		<para>
			Each operating system has a different raw Ethernet interface and so some abstraction was needed to support the toolkit for all environments. Our solution was the <structname>channel</structname> which is implemented like a <varname>FILE</varname> pointer but is used like a file descriptor. All toolkit programs, with a few exceptions, perform raw Ethernet I/O by opening a <structname>channel</structname>, reading and writing to it and then closing it.
			</para>
		<section id="support-channel">
			<title>
				channel
				</title>
			<para>
				The <structname>channel</structname> structure contains enough information to perform raw Ethernet I/O in several common runtime environments; however, portions of the structure vary depending on the environment. These differences are appled by compile time constants that include required structure members and exclude others. The common structure members are identified and described below. The others elements are not discussed because they may change.
				</para>
<programlisting>
typedef struct __packed <varname>channel</varname>
{
        signed <varname>fd</varname>;
        signed <varname>id</varname>;
        char const * <varname>name</varname>;
        uint8_t <varname>peer</varname> [<constant>ETHER_ADDR_LEN</constant>];
        uint8_t <varname>host</varname> [<constant>ETHER_ADDR_LEN</constant>];
        uint16_t <varname>type</varname>;

	 ... &lt;operating system dependent data&gt; ...

        signed <varname>timeout</varname>;
        flag_t <varname>flags</varname>;
} <varname>CHANNEL</varname>;
</programlisting>
			<variablelist>
				<varlistentry>
					<term>
						.<varname>fd</varname>
						</term>
					<listitem>
						<para>
						Socket file descriptor.
							</para>
						</listitem>
					</varlistentry>
				<varlistentry>
					<term>
						.<varname>id</varname>
						</term>
					<listitem>
						<para>
						Ethernet device index. The index only applies when the toolkit is compiled for <application>LibPcap</application> or <application>WinPcap</application>.
							</para>
						</listitem>
					</varlistentry>
				<varlistentry>
					<term>
						.<varname>name</varname>
						</term>
					<listitem>
						<para>
						The interface name. On Linux, ethernet names are typically <quote>eth0</quote>,  <quote>eth1</quote> and so on. On Mac OS X, interface names are <quote>en0</quote>,  <quote>en1</quote> and so on.
							</para>
						</listitem>
					</varlistentry>
				<varlistentry>
					<term>
						.<varname>peer</varname>
						</term>
					<listitem>
						<para>
						The Ethernet hardware address of some remote device. It is used to encode the <acronym>ODA</acronym> field of outgoing Ethernet frames and format some console messages. It is initialized to the Intellon Local Management Address, <constant>00:B0:52:00:00:01</constant> for HomePlug AV applications. Application programs can,  and often do, replace this value at runtime.
							</para>
						</listitem>
					</varlistentry>
				<varlistentry>
					<term>
						.<varname>host</varname>
						</term>
					<listitem>
						<para>
						The Ethernet hardware address of the host computer. It is used to encode the <acronym>OSA</acronym> field of outgoing Ethernet frames and format some console messages. This address is initialized to the hardware address assigned to the interface by the host operating system. The value should not change.
							</para>
						</listitem>
					</varlistentry>
				<varlistentry>
					<term>
						.<varname>type</varname>
						</term>
					<listitem>
						<para>
						The Ethernet type/length field. It is used to encode the <acronym>MTYPE</acronym> field of outgoing Ethernet frames. The values is initialized to <constant>0x88E1</constant> for HomePlug AV application and <constant>0x887B</constant> for HomePlug 1.0 application. The value should not change.
							</para>
						</listitem>
					</varlistentry>
				<varlistentry>
					<term>
						.<varname>timeout</varname>
						</term>
					<listitem>
						<para>
						A time interval. On <productname>Linux</productname> and <productname>Mac OS X</productname>, it is the maximum time that the application will wait for a device to respond when a response is expected. With <productname>LibPcap</productname> and <productname>WinPcap</productname> it the mininum time the application will wait. It is initialized to <constant>50</constant> milliseconds which is a reasonable compromise but most toolkit programs allow the user to change this value.
							</para>
						</listitem>
					</varlistentry>
				<varlistentry>
					<term>
						.<varname>flags</varname>
						</term>
					<listitem>
						<para>
						A bitmap where each bit enables a special behavior during channel open or close or packet read or write. Of general interest is the <constant>CHANNEL_VERBOSE</constant> bit which prints outgoing and incoming frames on stderr in hexadecimal dump format. The verbose feature is implemented in for all toolkit programs that perform raw Ethernet I/O and is helpful when debugging device behavior.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			<para>
				Since toolkit applications typically communicate with one powerline device at a time, this structure is statically initialized in a stand-alone module that is linked into each application. It is possible to dynamically initialize it, if needed. The structure is declared in <ulink url="channel.h.html">channel.h</ulink> and statically defined in <ulink url="channel.c.html">channel.c</ulink>.
				</para>
			</section>
		<section id="support-closechannel">
			<title>
				closechannel
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>signed <function>closechannel</function></funcdef>
   					<paramdef>struct channel * <parameter>channel</parameter></paramdef>
   					</funcprototype>
				</funcsynopsis>
			<para>
				Close the Ethernet socket associated with a <structname>channel</structname> and free associated memory and data structures. Return <constant>0</constant> on success. Return <constant>-1</constant> on failure. This function is declared in <ulink url="channel.h.html">channel.h</ulink> and defined in <ulink url="closechannel.c.html">closechannel.c</ulink>.  
				</para>
			</section>
		<section id="support-openchannel">
			<title>
				openchannel
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>signed <function>openchannel</function></funcdef>
   					<paramdef>struct channel * <parameter>channel</parameter></paramdef>
   					</funcprototype>
				</funcsynopsis>
			<para>
				Open a raw Ethernet socket and associate it with the interface referenced by the <varname>channel</varname> structure <structname>.name</structname> member. Initialize the interface as needed. Interface initialization differs significantly from environment to environment. Store the socket descriptor stored in the <varname>channel</varname> structure <structname>.fd</structname> member and the interface hardware address stored in the <varname>channel</varname> structure <structname>.host</structname> member. Return <constant>0</constant> on success. Terminate the program with an error message on failure. This function is declared in <ulink url="channel.h.html">channel.h</ulink> and defined in <ulink url="openchannel.c.html">openchannel.c</ulink>.  
				</para>
			</section>
		<section id="support-readpacket">
			<title>
				readpacket
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>signed <function>readpacket</function></funcdef>
   					<paramdef>struct channel * <parameter>channel</parameter></paramdef>
					<paramdef>void * <parameter>packet</parameter></paramdef>
					<paramdef>signed <parameter>length</parameter></paramdef>
   					</funcprototype>
				</funcsynopsis>
			<para>
				Read one Ethernet frame from the specified channel. The frame is written into memory starting at address <varname>packet</varname> and is truncated to the specified <varname>length</varname>,  if necessary. Return the actual number of bytes read on success. Return <constant>0</constant> on timeout. Return <constant>-1</constant> on network error. This function behaves like the standard library <function>read</function> function. The target memory region remains unchanged on timeout or error. This function is declared in <ulink url="channel.h.html">channel.h</ulink> and defined in <ulink url="readpacket.c.html">readpacket.c</ulink>.  
				</para>
			<para>
				On systems using Berkeley Packet Filters, such as MacOS X, the <varname>ODA</varname> field is automatically replaced on transmission to prevent Ethernet address spoofing. This may not be true on other systems but the practice is becoming more common.
				</para>
			</section>
		<section id="support-sendpacket">
			<title>
				sendpacket
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>signed <function>sendpacket</function></funcdef>
   					<paramdef>struct channel * <parameter>channel</parameter></paramdef>
					<paramdef>void * <parameter>packet</parameter></paramdef>
					<paramdef>signed <parameter>length</parameter></paramdef>
   					</funcprototype>
				</funcsynopsis>
			<para>
				Write one Ethernet frame to the specified channel. The frame is read from memory starting at address <varname> packet</varname> and ending at the specified <varname>length</varname>. Return the actual number of bytes sent on success. Return <constant>0</constant> on timeout. Return <constant>-1</constant> on network error. The frame should be properly formatted as an ethernet frame and must be at least 60 bytes long or it will not be sent. This function behaves like the standard library <function>write</function> function. The source memory region is not modified. This function is declared in <ulink url="channel.h.html">channel.h</ulink> and defined in <ulink url="sendpacket.c.html">sendpacket.c</ulink>.  
				</para>
			</section>
		</section>
	<section id="support-network">
		<title>
			Network Functions
			</title>
	<section id="support-networkbridges">
		<title>
			NetworkBridges
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>size_t <function>NetworkBridges</function></funcdef>
    				<paramdef>struct channel * <parameter>channel</parameter></paramdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Search a channel for local powerline devices (bridges) and store their Ethernet hardware in consecutive <varname>memory</varname> locations. The memory <varname>extent</varname> is specified in bytes. The number of devices found is returned as the function value,  provided enough space is available to store all addressed. Unlike function <link linkend='support-networkdevices'>NetworkDevices</link>, the channel <varname>peer</varname> address is ignored. 
			</para>
		<para>
			We call local devices <quote>bridges</quote> because each serves as an Ethernet-to-Powerline bridge for the local host.
			</para>
		<example>
			<title>
				Enumerating Local Devices
				</title>
<programlisting>
#include &lt;net/if.h&gt;
#include &quot;../ether/channel.h&quot;
extern struct channel <varname>channel</varname>; 
uint8_t <varname>address</varname> [<constant>255</constant>][<constant>ETHER_ADDR_LEN</constant>]; 
size_t <varname>bridges</varname> = <function>NetworkBridges</function> (&amp;<varname>channel</varname>, <varname>address</varname>, sizeof (<varname>address</varname>));
size_t <varname>bridge</varname> = 0; 
while (<varname>bridge</varname> &lt; <varname>bridges</varname>)
{
   <function>binout</function> (<varname>address</varname> [<varname>bridge</varname>], <constant>ETHER_ADDR_LEN</constant>, <constant>':'</constant>, stdout);
   <function>putc</function> (<constant>'\n'</constant>, <varname>stdout</varname>);  
} 
</programlisting>
			<para>
				The code segment shown above illustrates how to use function <varname>NetworkBridges</varname> to identify all local devices. We do not need to set the <link linkend='support-channel'>channel</link> <varname>peer</varname> because <varname>NetworkBridges</varname> always uses the Intellon <varname>localcast</varname> address. Array <varname>address</varname> is declared with two dimensions to simplify access to individual addresses on return.  
				</para>
			</example>
		</section>
	<section id="support-networkdevices">
		<title>
			NetworkDevices
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>size_t <function>NetworkDevices</function></funcdef>
    				<paramdef>struct channel * <parameter>channel</parameter></paramdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Query a powerline device, specified by <link linkend='support-channel'>channel</link>, for neighboring network devices and store their Ethernet addresses in consecutive <varname>memory</varname> locations. The memory <varname>extent</varname> is specified in bytes. The number of devices found is returned as the function value, provided sufficient space is available to store all addresses. Unlike function <link linkend='support-networkbridges'>NetworkBridges</link>, the <structname>channel</structname> <varname>peer</varname> address is identifies the device to be queried. 
			</para>
		<example>
			<title>
				Enumerating Network Devices
				</title>
<programlisting>
#include &lt;net/if.h&gt;
#include &quot;../ether/channel.h&quot;
extern struct channel <varname>channel</varname>; 
uint8_t <varname>address</varname> [<constant>255</constant>][<constant>ETHER_ADDR_LEN</constant>]; 
size_t <varname>devices</varname> = <function>NetworkDevices</function> (&amp;<varname>channel</varname>, <varname>address</varname>, sizeof (<varname>address</varname>));
size_t <varname>device</varname> = <constant>0</constant>; 
while (<varname>device</varname> &lt; <varname>devices</varname>)
{
   <function>binout</function> (<varname>address</varname> [<varname>device</varname>], <constant>ETHER_ADDR_LEN</constant>, <constant>':'</constant>, <varname>stdout</varname>);
   <function>putc</function> (<constant>'\n'</constant>;, <varname>stdout</varname>);  
} 
</programlisting>
			<para>
				The code segment shown above illustrates how to use function <varname>NetworkDevices</varname> to identify all devices on a specific network. You must set the <link linkend='support-channel'>channel</link> <varname>peer</varname> address before calling <varname>NetworkDevices</varname>. Array <varname>address</varname> is declared with two dimensions to simplify access to individual addresses on return. If the <link linkend='support-channel'>channel</link> <varname>peer</varname> address is not the Ethernet <varname>broadcast</varname> or Intellon <varname>localcast</varname> address then the first address returned will be the <link linkend='support-channel'>channel</link> <varname>peer</varname> address.
				</para>
			</example>
		</section>
		</section>
	<section id="support-generic">
		<title>
			Generic Functions
			</title>
		<para>
			The functions in this chapter are generic and may have application beyond the Intellon Linux Toolkit. In some cases, these functions appear in other Intellon or Open Source software packages. In a few cases, the Toolkit may include complementary or supplementary support functions but only use one or two of them. For example, functions <function>memincr</function> and <function>memdecr</function> are both included but <function>memdecr</function> is not used.
			</para>
	<section id="support-binout">
		<title>
			binout
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>binout</function></funcdef>
    				<paramdef>void const * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
    				<paramdef>char <parameter>c</parameter></paramdef>
    				<paramdef>FILE * <parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Print a <varname>memory</varname> region as a series of binary octets separated by character <constant>c</constant>. Normally, character <constant>c</constant> will be <constant>BIN_EXTENDER</constant>, defined in file <ulink url="number.h.html">number.h</ulink>, but it could be any character value.  For example, specifying <varname>c</varname> as <constant>'-'</constant> and <varname>length</varname> as <constant>4</constant> would produce output looking something like <computeroutput>"10101010-1111111-00000000-11001100"</computeroutput> where each octet is expressed as a binary integer. A typical use might be to print a <acronym>register</acronym> in readable format. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='binout.c.html'>binout.c</ulink>.
			</para>
		</section>
	<section id="support-checksum32">
		<title>
			checksum32
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>unint32_t <function>checksum32</function></funcdef>
    				<paramdef>const uint32_t <parameter>memory</parameter> []</paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
   				<paramdef>uint32_t <parameter>checksum</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			<para>
				Return the 32 bit checksum of a <varname>memory</varname> region. The checksum is the one's complement of the XOR of all 32 bit words in the region. Argument <varname>length</varname> is the region extent in 32 bit words. Argument <varname>checksum</varname> is the reference checksum. The function will return the computed checksum when reference<varname>checksum</varname> is <constant>0</constant> and will return <constant>0</constant> if reference <varname>checksum</varname> equals the computed checksum. A typical use is to validate <acronym>PIB</acronym> and <acronym>NVM</acronym> files or compute new checksums when these files are created or modified. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='checksum32.c.html'>checksum32.c</ulink>.
				</para>
			<para>
				This function is similar to <link linkend='support-checksum-32'>checksum_32</link> but is used exclusively by API functions. It may be deprecated at some point in the future.
				</para>
		</section>
	<section id="support-checksum-32">
		<title>
			checksum_32
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>unint32_t <function>checksum_32</function></funcdef>
    				<paramdef>void const * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
   				<paramdef>uint32_t <parameter>checksum</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			<para>
				Return the 32 bit checksum of a <varname>memory</varname> region. The checksum is the one's complement of the XOR of all 32 bit words in the region. The region <varname>extent</varname> is specified in bytes but it will be rounded down to the nearest multiple of 4 bytes. Argument <varname>checksum</varname> is the reference checksum. The function will return the computed checksum when reference<varname>checksum</varname> is <constant>0</constant> and will return <constant>0</constant> if reference <varname>checksum</varname> equals the computed checksum. A typical use is to validate <acronym>PIB</acronym> and <acronym>NVM</acronym> files or compute new checksums when these files are created or modified. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='checksum_32.c.html'>checksum_32.c</ulink>.
				</para>
			<para>
				This function is similar to function <link linkend='support-checksum32'>checksum32</link> however there is no need to cast <varname>memory</varname> to <varname>uint32_t</varname> and there is no need to round <varname>extent</varname> down to a multiple of 4 bytes before calling the function because both operations are performed internally. Also, there is no unecessary endian manipulation of the checksum. It is the prefered method of computing a checksum.
				</para>
		</section>
	<section id="support-decout">
		<title>
			decout
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>decout</function></funcdef>
    				<paramdef>void const * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
    				<paramdef>char <parameter>c</parameter></paramdef>
    				<paramdef>FILE * <parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Print a <varname>memory</varname> region as a series of decimal octets separated by character <constant>c</constant>. Normally, character <constant>c</constant> will be <constant>DEC_EXTENDER</constant>, defined in file <ulink url="number.h.html">number.h</ulink>, but it could be any character value.  For example, specifying <varname>c</varname> as <constant>'.'</constant> and <varname>length</varname> as <constant>4</constant> would produce output looking something like <computeroutput>"192.168.099.001"</computeroutput> where each octet is expressed as a decimal integer. A typical use might be to print an <acronym>IP</acronym> or <acronym>MAC</acronym> address in readable format. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='decout.c.html'>decout.c</ulink>.
			</para>
		</section>
	<section id="support-endian">
		<title>
			endian
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>endian</function></funcdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Reverse the byte order of a <varname>memory</varname> region. It is a variable length version of functions like <function>__bswap_16</function>, <function>__bswap_32</function> and <function>__bswap_64</function>. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='endian.c.html'>endian.c</ulink>.
			</para>
		</section>
	<section id="support-fdchecksum32">
		<title>
			fdchecksum32
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>unit32_t <function>fdchecksum32</function></funcdef>
    				<paramdef>int <parameter>fd</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
   				<paramdef>unit32_t <parameter>checksum</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			<para>
				Return the 32 bit checksum of a file region starting from the current file position. The checksum is the one's complement of the XOR or of all 32 bit words in the region. Argument <varname>length</varname> must be specified in 32 bit words, not bytes. Argument <varname>checksum</varname> is the reference checksum. The function will return the computed checksum when reference<varname>checksum</varname> is <constant>0</constant> and will return <constant>0</constant> if reference <varname>checksum</varname> equals the computed checksum. A typical use is to validate <acronym>NVM</acronym> files header by header or section by section. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='fdchecksum32.c.html'>fdchecksum32.c</ulink>.
				</para>
		</section>
	<section id="support-fdchecksum-32">
		<title>
			fdchecksum_32
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>unit32_t <function>fdchecksum_32</function></funcdef>
    				<paramdef>int <parameter>fd</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
   				<paramdef>unit32_t <parameter>checksum</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			<para>
				Return the 32 bit checksum of a file region starting from the current file position. The checksum is the one's complement of the XOR or of all 32 bit words in the region. Argument <varname>extent</varname> is specified in bytes but is rounded down to the nearest multiple of 4 bytes. Argument <varname>checksum</varname> is the reference checksum. The function will return the computed checksum when reference<varname>checksum</varname> is <constant>0</constant> and will return <constant>0</constant> if reference <varname>checksum</varname> equals the computed checksum. A typical use is to validate <acronym>NVM</acronym> files header by header or section by section. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='fdchecksum_32.c.html'>fdchecksum_32.c</ulink>.
				</para>
			<para>
				This function is similar to function <link linkend='support-fdchecksum32'>fdchecksum32</link> but there is no need to round <varname>extent</varname> down to the nearest multiple of 4 bytes before calling the function because that is done internally. Also, there is no unecessary endian manuipulation of the checksum.
				</para>
		</section>
	<section id="support-filepar">
		<title>
			filepart
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>char const * <function>filepart</function></funcdef>
    				<paramdef>char const * <parameter>pathname</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			<para>
				Return the address of the filename portion of a <varname>pathname</varname> string. The filename portion is everything after the rightmost path separator. If a path separator is not present then the address of the <varname>pathname</varname> string is returned. This function is similar to the <acronym>POSIX</acronym> <constant>basename</constant> function but it returns an empty string whenever the rightmost character is a path separator. The path separator can be either slash (<constant>'/'</constant>) or backslash (<constant>'\\'</constant>). The function is declared in <ulink url='files.h.html'>files.h</ulink> and defined in <ulink url='filepart.c.html'>filepart.c</ulink>.
				</para>
		</section>
	<section id="support-hexdecode">
		<title>
			hexdecode
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>hexdecode</function></funcdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
   				<paramdef>char const <parameter>buffer</parameter> []</paramdef>
   				<paramdef>size_t <parameter>length</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Decode a <varname>memory</varname> region as a string of <acronym>ASCII</acronym> hexadecimal digits. Convert memory until the buffer or memory exhausts and return the string length. Allow three (3) string characters for each memory byte to be decoded. The number of bytes decoded will be the lesser of argument <varname>length</varname> divided by <constant>3</constant> or argument <varname>extent</varname>. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='hexdecode.c.html'>hexdecode.c</ulink>.
			</para>
		</section>
	<section id="support-hexdump">
		<title>
			hexdump
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>void <function>hexdump</function></funcdef>
				<paramdef>void const * <parameter>memory</parameter></paramdef>
				<paramdef>size_t <parameter>offset</parameter></paramdef>
				<paramdef>size_t <parameter>extent</parameter></paramdef>
				<paramdef>FILE * <parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Print a full or partial <varname>memory</varname> region in hexadecimal format showing memory offsets, hexadecimal byte values and ASCII character values. Argument <varname>memory</varname> contains some memory region. Argument <varname>extent</varname> is the region length. Argument <varname>offset</varname> is the starting display location. Locations <varname>memory</varname> [<varname>offset</varname>] up to <varname>memory</varname> [<varname>extent</varname>] are displayed, allowing a partial dump of the memory region. An <varname>offset</varname> of <constant>0</constant> will display the entire region. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='hexdump.c.html'>hexdump.c</ulink>. 			
			</para>
		<para>
			This function is similar to but different from function <link linkend='support-hexview'>hexview</link> .
			</para>
		</section>
	<section id="support-hexencode">
		<title>
			hexencode
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>hexencode</function></funcdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
   				<paramdef>char const * <parameter>string</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Encode a <varname>memory</varname> region with the binary equivalent of an <acronym>ASCII</acronym> hexadecimal string. Return the number of bytes encoded or <constant>0</constant> on error. The value of <varname>errno</varname> is set to <constant>EINVAL</constant> if the number of bytes encoded is less than <varname>extent</varname> or the entire string cannot be converted due to illegal digits or excessive digits. Ignore optional <constant>HEX_EXTENDER</constant> characters separating octets in argument <varname>string</varname>. Constant <constant>HEX_EXTENDER</constant> is defined in file <ulink url='number.h.html'>number.h</ulink>. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='hexencode.c.html'>hexencode.c</ulink>.
			</para>
		</section>
	<section id="support-hexin">
		<title>
			hexin
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>ssize_t <function>hexin</function></funcdef>
    				<paramdef>void const * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
    				<paramdef>FILE * <parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			This function is similar to <link linkend="support-hexencode">hexencode</link> but it reads from file, instead of a string and ignores non-hexadecimal text and comments within the input stream. Incoming text is binary encoded and written to the specified <varname>memory</varname> region. The actual number of bytes encoded is returned or <constant>-1</constant> on error. See the <ulink url='efsu.7.html'>efsu</ulink> man page for a thorough explanation of function behavior. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='hexin.c.html'>hexin.c</ulink>.
			</para>
		</section>
	<section id="support-hexout">
		<title>
			hexout
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>hexout</function></funcdef>
    				<paramdef>void const * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
    				<paramdef>char <parameter>c</parameter></paramdef>
    				<paramdef>FILE * <parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Print a <varname>memory</varname> region as a series of decimal octets separated by character <constant>c</constant>. Normally, character <constant>c</constant> will be <constant>HEX_EXTENDER</constant>, defined in file <ulink url="number.h.html">number.h</ulink>, but it could be any character value.  For example, specifying <varname>c</varname> as <constant>':'</constant> and <varname>extent</varname> as <constant>6</constant> would produce output looking something like <computeroutput>"00:B0:52:DA:DA:01"</computeroutput> where each octet is expressed as a hexadecimal integer. A typical use might be to print a <acronym>MAC</acronym> or <acronym>Ethernet</acronym> address in readable format. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='hexout.c.html'>hexout.c</ulink>.
			</para>
		</section>
	<section id="support-hexstring">
		<title>
			hexstring
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>char * <function>hexstring</function></funcdef>
    				<paramdef>char <parameter>buffer</parameter> []</paramdef>
				<paramdef>size_t <parameter>length</parameter></paramdef>
				<paramdef>void const * <parameter>memory</parameter></paramdef>
				<paramdef>size_t <parameter>extent</parameter></paramdef>
 				</funcprototype>
			</funcsynopsis>
		<para>
			Convert a <varname>memory</varname> region to a <acronym>NUL</acronym> terminated string and return the string address. This function is identical to function <link linkend='support-hexdecode'>hexdecode</link> but it return the string address instead of the number of characters decoded. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='hexstring.c.html'>hexstring.c</ulink>.
			</para>
		</section>
	<section id="support-hexview">
		<title>
			hexview
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>void <function>hexview</function></funcdef>
				<paramdef>void const * <parameter>memory</parameter></paramdef>
				<paramdef>size_t <parameter>offset</parameter></paramdef>
				<paramdef>size_t <parameter>extent</parameter></paramdef>
				<paramdef>FILE * <parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Print a partial <varname>memory</varname> region in hexadecimal format showing memory offsets, hexadecimal byte values and ASCII character values. Argument <varname>memory</varname> contains part of a larger memory region, much like a file window. Argument <varname>extent</varname> is the window length. Argument <varname>offset</varname> is the relative offset of the window within the region. Locations <varname>memory</varname> [<constant>0</constant>] up to but excluding  <varname>memory</varname> [<varname>extent</varname>] are displayed as a partial dump, providing a window into the region. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='hexview.c.html'>hexview.c</ulink>. 			</para>
		<para>
			This function is similar to but different from function <link linkend='support-hexdump'>hexdump</link>.
			</para>
		</section>
	<section id="support-memdecr">
		<title>
			memdecr
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>memdecr</function></funcdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Decrement a multi-byte <varname>memory</varname> region. Return <constant>0</constant> on success or <constant>-1</constant> if all bytes have decremented to <constant>0x00</constant>. For example, <computeroutput>{ 0xFF, 0xFF, 0xFF }</computeroutput> decrements to <computeroutput>{ 0xFF, 0xFF, 0xFE }</computeroutput> and <computeroutput>{ 0xFF, 0x00, 0x00 }</computeroutput> decrements to <computeroutput>{ 0xFE, 0xFF, 0xFF }</computeroutput>. A typical use is to iterate through a range if <acronym>IP</acronym> or <acronym>MAC</acronym> address values. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='memdecr.c.html'>memdecr.c</ulink>.
			</para>
		</section>
	<section id="support-memincr">
		<title>
			memincr
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>memincr</function></funcdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Increment a multi-byte <varname>memory</varname> region. Return <constant>0</constant> on success or <constant>-1</constant> once all bytes have been incremented to <constant>0xFF</constant>. For example <computeroutput>{ 0x00, 0x00, 0x00 }</computeroutput> increments to <computeroutput>{ 0x00, 0x00, 0x01 }</computeroutput> and <computeroutput>{ 0x00, 0xFF, 0xFF }</computeroutput> increments to <computeroutput>{ 0x01, 0x00, 0x00 }</computeroutput>. A typical use is to iterate through a range of <acronym>IP</acronym> or <acronym>MAC</acronym> address values. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='memincr.c.html'>memincr.c</ulink>.
			</para>
		</section>
	<section id="support-memout">
		<title>
			memout
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>memout</function></funcdef>
    				<paramdef>void const * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>extent</parameter></paramdef>
				<paramdef>char const * <parameter>format</parameter></paramdef>
				<paramdef>unsigned <parameter>group</parameter></paramdef>
    				<paramdef>signed <parameter>c</parameter></paramdef>
    				<paramdef>FILE * <parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Print a <varname>memory</varname> region as a series of octet groups wach separated by character <constant>c</constant>. The <varname>group</varname> argument specifies the number of octets per group. The <varname>format</varname> argument determines how each octet is displayed. Normally, character <constant>c</constant> will be one of <constant>BIN_EXTENDER</constant>, <constant>DEC_EXTENDER</constant> or <constant>HEX_EXTENDER</constant> as defined in file <ulink url="number.h.html">number.h</ulink>, but it could be any character value. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='memout.c.html'>memout.c</ulink>.
			</para>
		</section>
	<section id="support-memswap">
		<title>
			memswap
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>memswap</function></funcdef>
    				<paramdef>void  * <parameter>buffer1</parameter></paramdef>
    				<paramdef>void  * <parameter>buffer2</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Exchange the contents of one buffer with that of another. No provision is made for buffer overlap. No value is returned. A typical use might be to exchange source and destination addresses in an ethernet packet. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='memswap.c.html'>memswap.c</ulink>.
			</para>
		</section>
	<section id="support-strdecr">
		<title>
			strdecr
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>strdecr</function></funcdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
    				<paramdef>byte <parameter>min</parameter></paramdef>
    				<paramdef>byte <parameter>max</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Decrement a multi-byte <varname>memory</varname> region using only ASCII character values in the range <varname>min</varname> through <varname>max</varname>. Return <constant>0</constant> on success or <constant>-1</constant> once all characters have been decremented to the value of argument <varname>min</varname>. For example,  if argument <varname>min</varname> is <constant>'A'</constant> and argument <varname>max</varname> is <constant>'Z'</constant> then <computeroutput>{ 'A', 'B', 'C' }</computeroutput> decrements to <computeroutput>{ 'A', 'B', 'B' }</computeroutput> and <computeroutput>{ 'B', 'Z', 'Z' }</computeroutput> decrements to <computeroutput>{ 'A', 'A', 'A' }</computeroutput>. A typical use is to generate a sequence of distinct character strings to seed encryption key functions. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='strdecr.c.html'>strdecr.c</ulink>.
			</para>
		</section>
	<section id="support-strfbits">
		<title>
			strfbits
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>size_t <function>strfbits</function></funcdef>
    				<paramdef>char const <parameter>buffer</parameter> []</paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
    				<paramdef>char const * <parameter>operands</parameter> []</paramdef>
    				<paramdef>char const * <parameter>operator</parameter></paramdef>
				<paramdef>unsigned <parameter>flagword</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Encode a <varname>buffer</varname> with an enumerated list of the <varname>operands</varname> associated with the corresponding bits in <varname>flagword</varname>. separate enumerated <varname>operands</varname> with an <varname>operator</varname> string. For example, given <computeroutput>char const *operands [] = { "loop", "wait",  "busy" }</computeroutput> and <computeroutput>unsigned flagword = 0x05</computeroutput> then <computeroutput>strfbits (buffer,  length, operands, "|", flagword)</computeroutput> would encode buffer with <constant>"loop|busy"</constant>. Observe that each bit set in <varname>flagword</varname> appears in <varname>buffer</varname> as the corresponding string from <varname>operands</varname>. A typical application for this function is the enumeration of flagword states. The function is declared in <ulink url='format.h.html'>format.h</ulink> and defined in <ulink url='strfbits.c.html'>strfbits.c</ulink>.
			</para>
		</section>
	<section id="support-strincr">
		<title>
			strincr
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>strincr</function></funcdef>
    				<paramdef>void  * <parameter>memory</parameter></paramdef>
    				<paramdef>size_t <parameter>length</parameter></paramdef>
    				<paramdef>byte <parameter>min</parameter></paramdef>
    				<paramdef>byte <parameter>max</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Increment a multi-byte <varname>memory</varname> region using only ASCII character values in the range <varname>min</varname> through <varname>max</varname>. Return <constant>0</constant> on success or <constant>-1</constant> once all characters have been incremented to the value of argument <varname>max</varname>.  For example,  if argument <varname>min</varname> is <constant>'A'</constant> and argument <varname>max</varname> is <constant>'Z'</constant> then <computeroutput>{ 'A', 'B', 'C' }</computeroutput> increments to <computeroutput>{ 'A', 'B', 'D' }</computeroutput> and <computeroutput>{ 'A', 'Z', 'Z' }</computeroutput> increments to <computeroutput>{ 'B', 'A', 'A' }</computeroutput>. A typical use is to generate a sequence of distinct character strings to seed encryption key functions. The function is declared in <ulink url='memory.h.html'>memory.h</ulink> and defined in <ulink url='strincr.c.html'>strincr.c</ulink>.
			</para>
		</section>
	<section id="support-todigit">
		<title>
			todigit
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>unsigned <function>todigit</function></funcdef>
    				<paramdef>unsigned <parameter>c</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Return the integer value of character <varname>c</varname> interpreted as digit in the base 36 number system. It is called by many encode functions to support number base conversion. If the value of <varname>c</varname> is <constant>'0'</constant> through <constant>'9'</constant> then integer <constant>0</constant> through <constant>9</constant> is returned.  If the value of <varname>c</varname> is <constant>'A'</constant> through <constant>'Z'</constant> or <constant>'a'</constant> through <constant>'z'</constant> then integer <constant>10</constant> through <constant>35</constant> is returned. The function is declared in <ulink url='number.h.html'>number.h</ulink> and defined in <ulink url='todigit.c.html'>todigit.c</ulink>.
			</para>
		</section>
	<section id="support-typename">
		<title>
			typename
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>char const * <function>typename</function></funcdef>
    				<paramdef>const struct _type_ <parameter>list</parameter> []</paramdef>
   				<paramdef>size_t <parameter>size</parameter></paramdef>
   				<paramdef>type_t <parameter>type</parameter></paramdef>
   				<paramdef>char const * <parameter>name</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Return the name associated with a message <varname>type</varname> by searching a list arranged in ascending order by message type. Return argument <varname>name</varname> as the function value if the message <varname>type</varname> is not present in the <varname>list</varname>. Data types <varname>struct _type_</varname> and <varname>type_t</varname> are defined in file <ulink url="types.h.html">types.h</ulink>. A typical use might be to return the name of message based on the message type. The function is declared in <ulink url='symbol.h.html'>symbol.h</ulink> and defined in <ulink url='typename.c.html'>typename.c</ulink>.
			</para>
		</section>
		</section>
	<section id="support-mmedump">
		<title>
			Message Debug Functions
			</title>
		<para>
			Message debug functions are not needed for proper toolkit operation but they can be useful during development, debugging and testing phases of product development. They are specific to HomePlug AV messages only.
			</para>
	<section id="support-mmecode">
		<title>
			MMECode
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>char const * <function>MMECode</function></funcdef>
				<paramdef>uint16_t <parameter>MMTYPE</parameter></paramdef>
				<paramdef>uint8_t <parameter>MSTATUS</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Return text that explains the status code for a given Intellon vendor-specific management message. Argument <varname>MMTYPE</varname> is an unsigned integer in the range <constant>0xA000</constant> through <constant>0xAFFF</constant> and must exactly match the <varname>MMTYPE</varname> of the message returning the status code. For example, the <varname>CNF</varname> variant of a message is currently the only variant that has an <varname>MSTATUS</varname> field and so other variants return a default string. The function is declared in <ulink url="mme.h.html">mme.h</ulink> and defined in <ulink url="MMECode.c.html">MMECode.c</ulink>. 
			</para>
		<para>
			Inclusion of this function can increase application size by 3kb because the text associated with all Intellon vendor-specific management messages and errors are included whether needed or not. Conditional compilation statements are provided internally to suppress the full table with a terse substitute.
			</para>
		<para>
			Although the <application>Bootloader</application> and firmware share some common Vendor Specific Management Messages, the two programs may return different codes for a given message and error condition. Where there are conflicts, Bootloader codes take precedence over firmware codes because it is unlikely that users will .issue the same messages to a device running firmware.
			</para>
		</section>
	<section id="support-mmemode">
		<title>
			MMEMode
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>char const * <function>MMEMode</function></funcdef>
				<paramdef>uint16_t <parameter>MMTYPE</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Return the mode of a given management message type as a string. The mode is determined by the two least significant bits of argument  <varname>MMTYPE</varname>. The mode string will be one of <quote>REQ</quote>, <quote>CNF</quote>,  <quote>IND</quote> or <quote>RSP</quote>. The function is declared in <ulink url="ihp.h.html">ihp.h</ulink> and defined in <ulink url="MMEMode.c.html">MMEMode.c</ulink>. 
			</para>
		<para>
			Most management messages have a request and a confirmation variant while a few have an indication and a response variant. Requests originate from the host and are acknolwedged by a confirmation from the device. Indications originate from a device and are acknowledged by a response from the host.
			</para>
		</section>
	<section id="support-mmename">
		<title>
			MMEName
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>char const * <function>MMEName</function></funcdef>
				<paramdef>uint16_t <parameter>MMTYPE</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Return the name associated with a given management message type. The name is the mnemonic used to distinguish one message type from another in the <citetitle>HomePlug AV Specification</citetitle> or Intellon <citetitle>Firwmare Technical Reference Manual</citetitle>. Argument <varname>MMTYPE</varname> is an unsigned integer in the range <constant>0x0000</constant> through <constant>0xAFFF</constant>. The request, confirmation, indication and response variants of a management message will all return the same message name. The function is declared in <ulink url="mme.h.html">mme.h</ulink> and defined in <ulink url="MMEName.c.html">MMEName.c</ulink>. 
			</para>
		</section>
	<section id="support-mmepeek">
		<title>
			MMEPeek
			</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>void <function>MMEPeek</function></funcdef>
				<paramdef>void const * <parameter>memory</parameter></paramdef>
				<paramdef>size_t <parameter>length</parameter></paramdef>
				<paramdef>size_t length, FILE *<parameter>fp</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		<para>
			Prints an Intellon vendor-specific management message to stream <constant>fp</constant> in human readable format. Argument <varname>buffer</varname> is the message address and argument <varname>length</varname> is the message length in bytes. Output consists of a formatted header showing decoded header. The function is declared in <ulink url="mme.h.html">mme.h</ulink> and defined in <ulink url="MMEPeek.c.html">MMEPeek.c</ulink>. 
			</para>
		</section>
	</section>


	<section id="support-key">
		<title>
			Key Generation Functions
			</title>
		<para>
			Intellon applications use the SHA256 algorithm to compute unique HomePlug AV keys, including the Device Access Key (<acronym>DAK</acronym>), Network Membership Key (<acronym>NMK</acronym>) and Network Identifier (<acronym>NID</acronym>). The SHA256 algorithm is seeded, salted and rehashed differently for each type of HomePlug AV key. A different function is used to compute each type of HomePlug AV key but all of them call the SHA256 functions. The SHA256 algorithm returns a <constant>256</constant> bit (<constant>32</constant> byte) digest but only the upper <constant>128</constant> bits (<constant>16</constant> bytes) are used for HomePlug AV keys. 
			</para>
		<example>
			<title>
				SHA256 Digest Computation
				</title>
		<para>
			The following code example illustrates how to generate, rehash and print an SHA256 digest, or key, from a user-defined seed string and salt string. This logic is typical of that used to generate HomePlug AV compliant keys. See the HomePlug AV Specification for the specific rules used to generate each type of key.
			</para>
<programlisting><![CDATA[
#include <stdio.h>

#include "../crypt/SHA256.h"

#include "../crypt/SHA256Reset.c"
#include "../crypt/SHA256Block.c"
#include "../crypt/SHA256Write.c"
#include "../crypt/SHA256Fetch.c"

struct sha256 sha256; 
char * seed = "ForMeToKnowAndYouToFindOut"; 
char * salt = "X$z@p"; 
byte digest [SHA256_DIGEST_SIZE];
int i; 

SHA256Reset (&sha256); 
SHA256Write (&sha256, (byte *)(seed), strlen (seed)); 
SHA256Write (&sha256, (byte *)(salt), strlen (salt)); 
SHA256Fetch (&sha256, digest); 

for (i = 0; i < 999; i++)
{
	SHA256Reset (&sha256); 
	SHA256Write (&sha256, digest, sizeof (digest)); 
	SHA256Fetch (&sha256, digest); 
}
for (i = 0;  i < 16; i++)
{
	printf ("%02x", digest [i]); 
}
printf ("\n"); 
]]></programlisting>
			<para>
				Above, we declare struct <varname>sha256</varname> and initialize it using function <link linkend='support-SHA256Reset'>SHA256Reset</link>. We then write a user-defined seed string (or password) followed by an optional salt string to the digest using function <link linkend='support-SHA256Write'>SHA256Write</link>. The resulting digest (or key) is obtained by calling function <link linkend='support-SHA256Fetch'>SHA256Fetch</link>. Constant <constant>SHA256_DIGEST_SIZE</constant> is defined in <ulink url='SHA256.h.html'>SHA256.h</ulink>. Although the digest is probably secure enough at this point, we rehash it <constant>999</constant> times for good measure. We then print the first <constant>16</constant> bytes of the result because HomePlug AV keys are always <constant>16</constant> bytes long.
				</para>
			</example>
		<section id="support-MACPasswords">
			<title>
				MACPasswords
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>MACPasswords</function></funcdef>
   					<paramdef>uint32_t<parameter>vendor</parameter></paramdef>
   					<paramdef>uint32_t<parameter>device</parameter></paramdef>
   					<paramdef>uint32_t<parameter>number</parameter></paramdef>
					<paramdef>unsigned <parameter>count</parameter></paramdef>
 					<paramdef>unsigned <parameter>bunch</parameter></paramdef>
 					<paramdef>unsigned <parameter>space</parameter></paramdef>
 					<paramdef>flag_t <parameter>flags</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
			<para>
				Print a range of device addresses and user passwords on stdout. The calling application must split the starting device address into a three-byte <acronym>OUI</acronym> and three-byte device number and pass them as the unsigned 32-bit integers <varname>vendor</varname> and <varname>device</varname>, respectively. Argument <varname>device</varname> is the first device number in the range and <varname>number</varname> is the final device number. Argument <varname>count</varname> is the number of uppercase letters comprising a password. Passwords contain this many letters but the letters are grouped for easy reading. Letter groups are separated by hyphens. Argument <varname>bunch</varname> defines how many letters form each group. Argument <varname>space</varname> is the character used to separate groups of letters. Argument <varname>flags</varname> enables or disables function features such as insertion of a <quote>used</quote> flag for use by the Intellon Production Test System or the omission of the device address on output. The output of this function is similar to that produced by the <application>DB Builder</application> utility distributed with the <acronym>PTS</acronym>. This function is declared in <ulink url="keys.h.html">keys.h</ulink> and defined in <ulink url="MACPasswords.c.html">MACPasswords.c</ulink>. 				</para>
			</section>
		<section id="support-HPAVKeyDAK">
			<title>
				HPAVKeyDAK
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>HPAVKeyDAK</function></funcdef>
   					<paramdef> byte <parameter>DAK</parameter> []</paramdef>
					<paramdef>char const <parameter>string</parameter></paramdef>
  					</funcprototype>
				</funcsynopsis>
			<para>
				Encode buffer <varname>DAK</varname> with the Device Access Key (<acronym>DAK</acronym>) derived from the NUL terminated <varname>string</varname>. The <varname>string</varname> is salted, hashed and re-hashed using the <acronym>SHA256</acronym> algorithm. The <varname>DAK</varname> is always <constant>HPAVKEY_DAK_LEN</constant> bytes, defined in <ulink url="HPAVKey.h.html">HPAVKey.h</ulink>,  so no length argument is needed. See the HomePlug AV Specification for more information. This function is declared in <ulink url="HPAVKey.h.html">HPAVKey.h</ulink> and defined in <ulink url="HPAVKeyDAK.c.html">HPAVKeyDAK.c</ulink>.				
				</para>
			</section>
		<section id="support-HPAVKeyNMK">
			<title>
				HPAVKeyNMK
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>HPAVKeyNMK</function></funcdef>
   					<paramdef> byte <parameter>digest</parameter> []</paramdef>
					<paramdef>char const <parameter>string</parameter></paramdef>
  					</funcprototype>
				</funcsynopsis>
			<para>
				Encode buffer <varname>NMK</varname> with the Network Membership Key (<acronym>NMK</acronym>) derived from the NUL terminated <varname>string</varname>. The string is salted, hashed and re-hashed using the <acronym>SHA256</acronym> algorithm. The <varname>DAK</varname> is always <constant>HPAVKEY_NMK_LEN</constant> bytes,  as defined in <ulink url="HPAVKey.h.html">HPAVKey.h</ulink>,  so no length argument is needed. See the HomePlug AV Specification for more information. This function is declared in <ulink url="HPAVKey.h.html">HPAVKey.h</ulink> and defined in <ulink url="HPAVKeyNMK.c.html">HPAVKeyNMK.c</ulink>.				
				</para>
			</section>
		<section id="support-HPAVKeyNID">
			<title>
				HPAVKeyNID
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>HPAVKeyNID</function></funcdef>
   					<paramdef> byte <parameter>NID</parameter> []</paramdef>
   					<paramdef>byte const <parameter>NMK</parameter> []</paramdef>
					<paramdef>signed <parameter>level</parameter></paramdef>
  					</funcprototype>
				</funcsynopsis>
			<para>
				Encode buffer <varname>NID</varname> with the Network Identification Key (<acronym>NID</acronym>) derived from the 16-byte Network Membership Key (<acronym>NMK</acronym>). The <varname>NMK</varname> is hashed and re-hashed using the <acronym>SHA256</acronym> algorithm then encoded with the security <varname>level</varname>. The <varname>NID</varname> is always <constant>HPAVKEY_NID_LEN</constant> bytes,  as defined in <ulink url="HPAVKey.h.html">HPAVKey.h</ulink>,  so no length argument is needed. See the HomePlug AV Specification for more information. This function is declared in <ulink url="HPAVKey.h.html">HPAVKey.h</ulink> and defined in <ulink url="HPAVKeyNID.c.html">HPAVKeyNID.c</ulink>.				
				</para>
			</section>
		<section id="support-HPAVKeyOut">
			<title>
				HPAVKeyOut
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>HPAVKeyOut</function></funcdef>
   					<paramdef>byte const <parameter>digest</parameter> []</paramdef>
					<paramdef>size_t <parameter>length</parameter></paramdef>
   					<paramdef>char const * <parameter>phrase</parameter></paramdef>
					<paramdef>flag_t <parameter>flags</parameter></paramdef>
  					</funcprototype>
				</funcsynopsis>
			<para>
				Decode and print up to <varname>length</varname> bytes from buffer <varname>digest</varname> on stdout. Print <acronym>NUL</acronym> terminated <varname>phrase</varname> on the same line following the digest when bit <varname>HPAVKEY_VERBOSE</varname>, defined in <ulink url='HPAVKey.h.html'>HPAVKey.h</ulink>, is set in <varname>flags</varname>. This procedure prints keys and phrases in a standard column-oriented format that other applications can easily read and use. This function is declared in <ulink url="HPAVKey.h.html">HPAVKey.h</ulink> and defined in <ulink url="HPAVKeyOut.c.html">HPAVKeyOut.c</ulink>.				
				</para>
			</section>
		<section id="support-SHA256Block">
			<title>
				SHA256Block
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>SHA256Block</function></funcdef>
   					<paramdef>struct sha256 * <parameter>sha256</parameter></paramdef>
					<paramdef>void const * <parameter>memory</parameter></paramdef>
  					</funcprototype>
				</funcsynopsis>
			<para>
				Merge 64 bytes of memory into the current <acronym>SHA256</acronym> digest. This function performs the core computations required by the <acronym>SHA256</acronym> algoithm. It is called by function <link linkend='support-SHA256Fetch'><varname>SHA256Fetch</varname></link> and so there is no reason to call this function directly. The <varname>sha256</varname> structure is defined in <ulink url="SHA256.h.html">SHA256.h</ulink>. The function is declared in <ulink url="SHA256.h.html">SHA256.h</ulink> and defined in <ulink url="SHA256Block.c.html">SHA256Block.c</ulink>. 
				</para>
			</section>
		<section id="support-SHA256Fetch">
			<title>
				SHA256Fetch
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>SHA256Fetch</function></funcdef>
   					<paramdef>struct sha256 * <parameter>sha256</parameter></paramdef>
					<paramdef> byte <parameter>digest</parameter> []</paramdef>
  					</funcprototype>
				</funcsynopsis>
			<para>
				 Conclude <acronym>SHA256</acronym> computation and transfer the result to the named 32-byte <varname>digest</varname> then flush the <varname>sha256</varname> structure. The <varname>digest</varname> is always 32 bytes long regardless of the amount of information that has been written using function <link linkend='support-SHA256Write'>SHA256Write</link>. The <varname>sha256</varname> structure is defined in <ulink url="SHA256.h.html">SHA256.h</ulink>. This function is declared in <ulink url="SHA256.h.html">SHA256.h</ulink> and defined in <ulink url="SHA256Fetch.c.html">SHA256Fetch.c</ulink>.
				</para>
			<para>
				Once this function is called, the <varname>sha256</varname> structure is purged for security reasons. You must call <link linkend='support-SHA256Reset'>SHA256Reset</link> again before starting another hash or subsequent calls to this function or <link linkend='support-SHA256Write'>SHA256Write</link> will have unpredictable results. .
				</para>
			</section>
		<section id="support-SHA256Ident">
			<title>
				SHA256Ident
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>SHA256Ident</function></funcdef>
   					<paramdef>int <parameter>fd</parameter></paramdef>
   					<paramdef> byte <parameter>digest</parameter> []</paramdef>
 					</funcprototype>
				</funcsynopsis>
			<para>
				Compute the SHA256 digest from the content of a file. The digest serves as the file <quote>fingerprint</quote> and can be used to identify identical content despite filename changes. File descriptor <varname>fd</varname> is the subject file which must be positioned to the start befor calling this function. Buffer <varname>digest</varname> will be written with the computed 256-digest and must be <constant>SHA256_DIGEST_SIZE</constant> bytes long, as defined in <ulink url="SHA256.h.html">SHA256.h</ulink>. This function is declared in <ulink url="SHA256.h.html">SHA256.h</ulink> and defined in <ulink url="SHA256Ident.c.html">SHA256Ident.c</ulink>.  
				</para>
			</section>
		<section id="support-SHA256Match">
			<title>
				SHA256Match
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>SHA256Match</function></funcdef>
   					<paramdef>int <parameter>fd</parameter></paramdef>
   					<paramdef>byte const <parameter>digest</parameter> []</paramdef>
 					</funcprototype>
				</funcsynopsis>
			<para>
				Search a registry file for a known SHA256 digest. Return <constant>true</constant> on success or <constant>false</constant> on failure. File descriptor <varname>fd</varname> is the registry file which must be positioned to the start before calling this function. Buffer <varname>digest</varname> contains the known 256-bit digest and must be <constant>SHA256_DIGEST_SIZE</constant> bytes long, as defined in <ulink url='SHA256.h.html'>SHA256.h</ulink>. A registry file consists of 64-digit hexadecimal strings that represent SHA256 digest values. Optional text may be appear between the digest and newline to document digest significance. This function ignores such text. This function is declared in <ulink url="SHA256.h.html">SHA256.h</ulink> and defined in <ulink url="SHA256Match.c.html">SHA256Match.c</ulink>.  
				</para>
			</section>
		<section id="support-SHA256Print">
			<title>
				SHA256Print
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>SHA256Print</function></funcdef>
   					<paramdef>byte const <parameter>digest</parameter> []</paramdef>
   					<paramdef>char const * <parameter>string</parameter></paramdef>
 					</funcprototype>
				</funcsynopsis>
			<para>
				Print an SHA256 <varname>digest</varname> and optional <varname>string</varname> on <constant>stdout</constant>. Buffer <varname>digest</varname> must be <constant>SHA256_DIGEST_SIZE</constant> bytes long, as defined in <ulink url='SHA256.h.html'>SHA256.h</ulink>, which results in 64 hexadecimal digits on output. Variable length string is <constant>NUL</constant> terminated but may be <constant>NULL</constant>. If <varname>string</varname> is not <constant>NULL</constant> and is not empty then a space is inserted between the digest and the string on output. This function may be used to print SHA256 digests and optional strings in standard format,  such as a registry file. This function is declared in <ulink url="SHA256.h.html">SHA256.h</ulink> and defined in <ulink url="SHA256Print.c.html">SHA256Print.c</ulink>.  
				</para>
			</section>
		<section id="support-SHA256Reset">
			<title>
				SHA256Reset
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>SHA256Reset</function></funcdef>
   					<paramdef>struct sha256 * <parameter>sha256</parameter></paramdef>
 					</funcprototype>
				</funcsynopsis>
			<para>
				Initialize a <varname>sha256</varname> structure before computing a new <acronym>SHA256</acronym> digest. This function should be called once before calling <link linkend='support-SHA256Write'>SHA256Write</link> for the first time for a given digest. The <varname>sha256</varname> structure is defined in <ulink url="SHA256.h.html">SHA256.h</ulink>. This function is declared in <ulink url="SHA256.h.html">SHA256.h</ulink> and defined in <ulink url="SHA256Reset.c.html">SHA256Reset.c</ulink>.  
				</para>
			</section>
		<section id="support-SHA256Write">
			<title>
				SHA256Write
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>SHA256Write</function></funcdef>
   					<paramdef>struct sha256 * <parameter>sha256</parameter></paramdef>
					<paramdef>void const * <parameter>memory</parameter></paramdef>
					<paramdef>size_t <parameter>extent</parameter></paramdef>
  					</funcprototype>
				</funcsynopsis>
			<para>
				Writes a region of memory to the current <acronym>SHA256</acronym> digest contained in an <varname>sha256</varname> structure. An application may call this function any number of times to concatinate multiple memory regions before fetching the digest with function <function>SHA256Fetch</function>. The <varname>sha256</varname> structure is defined in <ulink url="SHA256.h.html">SHA256.h</ulink>.  This function is declared in <ulink url="SHA256.h.html">SHA256.h</ulink> and defined in <ulink url="SHA256Write.c.html">SHA256Write.c</ulink>.				
				</para>
			</section>
		</section>

	<section id="support-xml">
		<title>
			XML Editing Functions
			</title>
		<para>
			Intellon provides support for remote <acronym>PIB</acronym> management using <acronym>XML</acronym> instruction files. The concept is based on an <acronym>XML</acronym> schema that defines the elements and attributes needed to edit a <acronym>PIB</acronym> file. The schema is located in file <ulink url="piboffset.xsd">piboffset.xsd</ulink>. In practice, this schema could be used to edit any buffer containing data but we are only interested in editing <acronym>PIB</acronym> files here.
			</para>
		<para>
			Users may create <acronym>XML</acronym> files that conform to the schema and specify the <acronym>PIB</acronym> objects they want to change and how they want each to change. In brief, the files specify an <varname>offset</varname>, a data <varname>length</varname> and a data value. A data value has type <varname>dataString</varname>, <varname>dataHex</varname> or <varname>dataByte</varname> and may be a single data item or an array of data items. Each <acronym>XML</acronym> file should include a reference to the Intellon schema and be submitted to a validating XML parser,  such as <application>Internet Explorer</application> or <application>Firefox</application>,  to ensure that file structure and syntax are correct before use. An example <acronym>XML</acronym> file can be seen in <ulink url="piboffset.xml">piboffset.xml</ulink>.
			</para>
		<para>
			Editing involves the following steps. An example of these steps can be seen in the <ulink url="pxe.c.html">pxe</ulink> program source code and in function <ulink url="RdModWrPib2.c.html">RdModWrPib2.c</ulink> which is a component of the <ulink url="int6k2.7.html">int6k2</ulink> program.
			<orderedlist>
				<listitem>
					<para>
						Obtain a copy of the <acronym>PIB</acronym> to be edited. This can be done by opening a <acronym>PIB</acronym> file and reading the entire file into memory or by requesting the <acronym>PIB</acronym> directly from an active Intellon powerline device. The <acronym>PIB</acronym> length can be determined from the <acronym>PIB</acronym> header.
						</para>
					</listitem>
				<listitem>
					<para>
						Open the <acronym>XML</acronym> file, generate an <acronym>XML</acronym> parse tree and close the file. This can be done by passing the filename to function <link linkend="nodes-xmlopen">xmlopen</link>. It will perform all these steps and return the parse tree root node.
						</para>
					</listitem>
				<listitem>
					<para>
						Modify the <acronym>PIB</acronym> based to instructions stored in the parse tree. This is done by passing the parse tree, <acronym>PIB</acronym> buffer and <acronym>PIB</acronym> length to function <link linkend="nodes-xmledit">xmledit</link>. It will traverse the parse tree and apply changes to the buffer as defined in the parse tree.   
						</para>
					</listitem>
				<listitem>
					<para>
						Discard the parse tree. This can be done by passing the parse tree to function <link linkend="nodes-xmlfree">xmlfree</link>.
						</para>
					</listitem>
				<listitem>
					<para>
						Compute a new PIB checksum. This can be done by clearing the <acronym>PIB</acronym> checksum then passing the <acronym>PIB</acronym> buffer and <acronym>PIB</acronym> length to function <link linkend="support-checksum32">checksum32</link> with a checksum value of <constant>0</constant>.
						</para>
					</listitem>
				<listitem>
					<para>
						Write the <acronym>PIB</acronym> to file or transmit it over the network to an Intellon powerline device.
						</para>
					</listitem>
				</orderedlist>
			</para>
	<section id="nodes-xmledit">
		<title>
			xmledit
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>xmledit</function></funcdef>
   				<paramdef>struct node * <parameter>node</parameter></paramdef>
				<paramdef> byte <parameter>buffer</parameter> []</paramdef>
				<paramdef>size_t <parameter>length</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Write data into <varname>buffer</varname> based on offset and length values defined in <acronym>XML</acronym> parse tree, <varname>node</varname>. This function will not apply modifications having malformed structure or having an invalid or an illegal offset, length or data value. Use function <link linkend='nodes-xmlschema'>xmlschema</link> to print the current schema. The function is declared in <ulink url='nodes.h.html'>nodes.h</ulink> and defined in <ulink url='xmledit.c.html'>xmledit.c</ulink>. The <varname>node</varname> structure is defined in <ulink url='nodes.h.html'>nodes.h</ulink>.
			</para>
		</section>
	<section id="nodes-xmlfree">
		<title>
			xmlfree
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>xmlfree</function></funcdef>
   				<paramdef>struct node * <parameter>node</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Release memory associated with an XML parse tree. The function is declared in <ulink url='nodes.h.html'>nodes.h</ulink> and defined in <ulink url='xmlfree.c.html'>xmlfree.c</ulink>. The <varname>node</varname> structure is defined in <ulink url='nodes.h.html'>nodes.h</ulink>.
			</para>
		<para>
			The <varname>text</varname> member if the parse tree root node points to memory allocated by <link linkend="nodes-xmlscan">xmlscan </link> to store the original <acronym>XML</acronym> string. The application must either deallocate that memory before calling this function or store the text address and deallocate that memory after calling this function;  otherwise, memory leaks will result. 
			</para>
		</section>
	<section id="nodes-xmlnode">
		<title>
			xmlnode
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>struct node *<function>xmlnode</function></funcdef>
   				<paramdef>struct node *<parameter>node</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Create an empty node blow the specified node and return a pointer to it. A typical application can be seen in function <ulink url="xmlscan.c.html" >xmlscan.c</ulink>. The function is declared in <ulink url='nodes.h.html'>nodes.h</ulink> and defined in <ulink url='xmlnode.c.html'>xmlnode.c</ulink>. The <varname>node</varname> structure is defined in <ulink url='nodes.h.html'>nodes.h</ulink>.
			</para>
		</section>
	<section id="nodes-xmlopen">
		<title>
			xmlopen
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>struct node * <function>xmlopen</function></funcdef>
   				<paramdef>char const * <parameter>filename</parameter></paramdef>
   				</funcprototype>
			</funcsynopsis>
		<para>
			Open the named XML file, parse it and return the XML parse tree. The parse tree contains, among other things, all XML elements,  attributes and values specified in the file. The function is declared in <ulink url='nodes.h.html'>nodes.h</ulink> and defined in <ulink url='xmlopen.c.html'>xmlopen.c</ulink>. The <varname>node</varname> structure is defined in <ulink url='nodes.h.html'>nodes.h</ulink>.
			</para>
		<para>
			The returned parse tree is ready to traverse using struct <varname>node</varname> members <varname>above</varname>, <varname>below</varname>, <varname>prior</varname> and <varname>after</varname>. Each node has a <varname>line</varname>, <varname>type</varname> and <varname>test</varname> member. This function calls function <link linkend="nodes-xmlscan">xmlscan </link> to parse the file and generate the tree. The parse tree can be inspected by passing the root node to function <link linkend="nodes-xmltree">xmltree</link>.  
			</para>
		</section>
	<section id="nodes-xmlscan">
		<title>
			xmlscan
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>signed <function>xmlscan </function></funcdef>
   				<paramdef>struct node * <parameter>node</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Scan the XML string attached to the specified <varname>node</varname> and create a parse tree below it. Return <constant>0</constant> if parsing is successrul or <constant>-1</constant> if not. The function is declared in <ulink url='nodes.h.html'>nodes.h</ulink> and defined in <ulink url='xmlscan.c.html'>xmlscan.c</ulink>. The <varname>node</varname> structure is defined in <ulink url='nodes.h.html'>nodes.h</ulink>.
			</para>
		<para>
			The application must point the <varname>text</varname> member to a  copy of the XML string before calling this function because parsing is destructive and requires write access to the string. The application can search and manipulate the tree on return. The application should deallocate string memory before calling <link linkend="nodes-xmlfree">xmlfree</link>.   
			</para>
	<example id="nodes-example-1">
		<title>
			XML Source File
			</title>
		<para>
			The following is sample input to function <function>xmlscan</function>. The element and attribute names shown are for illustration and were selected to that they can be easily identified in the output. The parse tree from this file can be seen in the example for function <link linkend="nodes-example-2">xmltree</link>.
			</para>
<screen><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<xmlfile 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:noNamespaceSchemaLocation="myschema.xsd">
	<element name="Element1">
		<attribute name="Attribute1">
			1234567890
			</attribute>
		<attribute name="Attribute2">
			The quick brown fox jumped over the lazy dog.
			</attribute>
		</element>
	<element name="Element2">
		<attribute name="Attribute1">
			</attribute>
		<attribute name="Attribute2">
			The quick brown 
			fox jumped over 
			the lazy dog.
			</attribute>
		</element>
<!-- comments can go anywhere -->
	<element name="Element2">
		<attribute name="Attribute1"/>
		<attribute name="Attribute2">
			value2
			</attribute>
		</element>
	</xmlfile>
]]></screen>
			</example>
		</section>
	<section id="nodes-xmlschema">
		<title>
			xmlschema
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>xmlschema</function></funcdef>
   				<paramdef/>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Print an <acronym>XML</acronym> schema that supports function <link linkend='nodes-xmledit'>xmledit</link> on stdout. This function has no argument. The schema produced by this function is guaranteed to support the parse logic implemented by function <link linkend='nodes-xmledit'>xmledit</link>. Scheme element names are defined as constants in <ulink url='nodes.h.html'>nodes.h</ulink> so that they can be referenced by applications that create their own <acronym>XML</acronym> edit instructions. The function is declared in <ulink url='nodes.h.html'>nodes.h</ulink> and defined in <ulink url='xmlschema.c.html'>xmlschema.c</ulink>.
			</para>
		<para>
			The <varname>text</varname> member in the parse tree root node points to memory allocated by <link linkend="nodes-xmlscan">xmlscan </link> to store the original <acronym>XML</acronym> string. The application must either deallocate that memory before calling this function or store the text address and deallocate that memory after calling this function;  otherwise, memory leaks will result. 
			</para>
		<example>
			<title>
				XML Edit Schema
				</title>
<screen><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema' elementFormDefault='qualified'>
	<xs:element name='pib'>
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs='unbounded' ref='object'/>
				</xs:sequence>
			</xs:complexType>
		</xs:element>
	<xs:element name='object'>
		<xs:complexType>
			<xs:attribute name='name' use='required' type='xs:NCName'/>
			<xs:sequence>
				<xs:sequence>
					<xs:element ref='offset'/>
					<xs:element ref='length'/>
					</xs:sequence>
				<xs:choice>
					<xs:element ref='array'/>
					<xs:element ref='dataString'/>
					<xs:element ref='dataByte'/>
					</xs:choice>
				</xs:sequence>
			</xs:complexType>
		</xs:element>
	<xs:element name='length' type='xs:positiveInteger'/>
	<xs:element name='offset' type='xs:hexBinary'/>
	<xs:element name='array'>
		<xs:complexType>
			<xs:choice maxOccurs='unbounded'>
				<xs:element ref='dataByte'/>
				<xs:element ref='dataHex'/>
				</xs:choice>
			</xs:complexType>
		</xs:element>
	<xs:element name='dataString' type='xs:string'/>
	<xs:element name='dataHex' type='xs:hexBinary'/>
	<xs:element name='dataByte' type='xs:unsignedByte'/>
	</xs:schema>
]]></screen>
			<para>
				The schema shown above was produced by function <link linkend='nodes-xmlschema'>xmlschema</link>. It is should be used to validate <acronym>XML</acronym> edit instructions before submitting them to program <ulink url='pxe.7.html'>pxe</ulink>. 
				</para>
			</example>
		</section>
	<section id="nodes-xmltree">
		<title>
			xmltree
			</title>
		<funcsynopsis>
			<funcprototype>
  				<funcdef>void <function>xmltree</function></funcdef>
   				<paramdef>struct node * <parameter>node</parameter></paramdef>
  				</funcprototype>
			</funcsynopsis>
		<para>
			Print the XML parse tree on stdout. The function is declared in <ulink url='nodes.h.html'>nodes.h</ulink> and defined in <ulink url='xmltree.c.html'>xmltree.c</ulink>.
			</para>
		<example id="nodes-example-2">
			<title>
				XML Parse Tree 
				</title>
		<para>
			The following is sample output from function <function>xmltree</function>. The XML source is shown in the example for function <link linkend="nodes-example-1">xmlscan </link>. The numbers appearing down the left margin indicate the input line number from the XML source file parsed by function <link linkend="nodes-xmlscan">xmlscan </link>. The character codes indicate the node type and are defined in <ulink url="nodes.h.html">nodes.h</ulink>. The <varname>node</varname> structure is defined in <ulink url='nodes.h.html'>nodes.h</ulink>.
			</para>
<screen><![CDATA[
001 [?] [xml]
001 [ ] 	[version]
001 [=] 		[1.0]
001 [ ] 	[encoding]
001 [=] 		[UTF-8]
002 [<] [xmlfile]
002 [ ] 	[xmlns:xsi]
002 [=] 		[http://www.w3.org/2001/XMLSchema-instance]
002 [ ] 	[xsi:noNamespaceSchemaLocation]
002 [=] 		[myschema.xsd]
003 [<] 	[element]
003 [ ] 		[name]
003 [=] 			[Element1]
004 [<] 		[attribute]
004 [ ] 			[name]
004 [=] 				[Attribute1]
005 [>] 			[1234567890]
006 [/] 			[attribute]
007 [<] 		[attribute]
007 [ ] 			[name]
007 [=] 				[Attribute2]
008 [>] 			[The quick brown fox jumped over the lazy dog.]
009 [/] 			[attribute]
010 [/] 		[element]
011 [<] 	[element]
011 [ ] 		[name]
011 [=] 			[Element2]
012 [<] 		[attribute]
012 [ ] 			[name]
012 [=] 				[Attribute1]
013 [/] 			[attribute]
014 [<] 		[attribute]
014 [ ] 			[name]
014 [=] 				[Attribute2]
015 [>] 			[The quick brown fox jumped over the lazy dog.azy]
018 [/] 			[attribute]
019 [/] 		[element]
020 [!] 	[-- comments can go anywhere --]
021 [<] 	[element]
021 [ ] 		[name]
021 [=] 			[Element2]
022 [<] 		[attribute]
022 [ ] 			[name]
022 [=] 				[Attribute1]
023 [<] 		[attribute]
023 [ ] 			[name]
023 [=] 				[Attribute2]
024 [>] 			[value2]
025 [/] 			[attribute]
026 [/] 		[element]
027 [/] 	[xmlfile]
]]></screen>
			</example>
			</section>
		</section>
	<section id="support-lexographic">
		<title>
			Lexical Scanning Functions
			</title>
		<para>
			Lexical scanning functions are used by the CGI application to parse incoming HTTP requests. Collectively, they are an extremely generic lexical scanning library that will probably be replaced with something more specific to the CGI application. Consequently there is no description at this time.  
			</para>

	<!-- section id="support-lexintro">
		<title>
			Introduction
			</title>
		<para>
			Lexical scanning functions break a plain text input stream into lexicons, or <quote>tokens</quote>, that can be easily identified and used to direct program flow. Lexicon consist of one or more consecutive characters and can be broadly classified as either space,  comments,  names,  numbers, literals and puncuation and lexicons are oftern combined to form special lexicons that are appropriate to a specific application. For example, an single identifier may consist of one or more names seperated by punctuation.     
			</para>
		<para>
			The text to be scanned must be read into a character buffer. Buffer text is never moved or modified in this particular library implementation. Scanning is performed by manipulating pointers to characters within that buffer. The basic concept is illustrated below.
			</para>
<screen><![CDATA[
       The quick brown fox jumped over        the lazy dog.
       ^                   ^     ^                         ^
       |                   |     |                         | 
       start               |     final                     limit
                           first
]]></screen>
		<para>
			The illustration above shows an example content buffer and the pointers needed to manage the scan process. The buffer extends from address <varname>start</varname> to address <varname>limit</varname> minus <constant>1</constant>. If the content buffer contains a string then <varname>limit</varname> should point to the NUL terminator. The number of characters in the buffer is address <varname>limit</varname> minus address <varname>start</varname>. 
			</para>
		<para>
			The same applies to tokens with the buffer. Address <varname>first</varname> points to the first character of the current token and <varname>final</varname> points to the character after that token. As it happens, this is alwo the first character of the next token. In this example, the current token is <quote>jumped</quote> and <varname>final</varname> points to the space after that token. The number of characters in the current token is address <varname>final</varname> minus address <varname>first</varname>.
			</para>
		<para>
			The scan process begins by positioning both pointers <varname>first</varname> and <varname>final</varname> to the same character then advancing <varname>final</varname> until there is some reason to stop advancing. At that point, the characters from <varname>first</varname> up to (but excluding) <varname>final</varname> comprise the <varname>token</varname> string and <varname>final</varname> now points to the first character of the next token. We can now inspect the token, possibly extracting it from the buffer,  and peek at the next token.
			</para>
		<variablelist>
			<varlistentry>
				<term>
					start 
					</term>
				<listitem>
					<para>
						Points to the start of the content buffer. The scan process starts with this address. Initially, pointers <varname>first</varname> and <varname>final</varname> both point to this location and proceed from there. The value of <varname>start</varname> is set by function <function>scaninput()</function> and does not change during scan operations.
						</para>
					</listitem>
				</varlistentry>
			<varlistentry>
				<term>
					first 
					</term>
				<listitem>
					<para>
						Points to the start of the current token. At any given time, the current token extends from this buffer address up to (but excluding) the <varname>final</varname> buffer address. The value of <varname>first</varname> will range from <varname>start</varname> to <varname>final</varname>. Function <function>istoken</function> tests the value of all characters from position <varname>first</varname> up to position <varname>final</varname>.
						</para>
					</listitem>
				</varlistentry>
			<varlistentry>
				<term>
					final 
					</term>
				<listitem>
					<para>
						Points to the next character after the current token. This character effectively broke the previous scan operation and is normally called the <varname>break</varname> character. The value of <varname>final</varname> ranges from <varname>start</varname> to <varname>limit</varname>. Function <function>isbreak()</function> tests the value of this character. 
						</para>
					</listitem>
				</varlistentry>
			<varlistentry>
				<term>
					index
					</term>
				<listitem>
					<para>
						A temporary,  internal pointer used buy various scan,  copy and compare operations. It is not accessible to applications. Normally, it ranges from position <varname>first</varname> to <varname>final</varname>.
						</para>
					</listitem>
				</varlistentry>
			<varlistentry>
				<term>
					limit 
					</term>
				<listitem>
					<para>
						Points to the next character past the end of the buffer. This character is never accessed because the address is beyond the buffer extent. The value of <varname>limit</varname> is set by function <function>scaninput()</function> and does not change during scan operations.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		<example id="nodes-example-3">
			<title>
				SCAN Object 
				</title>
<screen><![CDATA[
typedef struct _scan_
{
        char const * start;
        char const * first;
        char const * final;
        char const * limit;
        char const * index;
        signed class;
        signed width;
        signed block;
        char * token;
} SCAN;]]></screen>
			</example>
			</section>
		<section id="lex-scaninput">
			<title>
				scaninput
				</title>
			<funcsynopsis>
				<funcprototype>
  					<funcdef>void <function>scaninput</function></funcdef>
   					<paramdef>struct scan * <parameter>content</parameter></paramdef>
    					<paramdef>char const <parameter>buffer</parameter> []</paramdef>
    					<paramdef>signed <parameter>length</parameter></paramdef>
 					</funcprototype>
				</funcsynopsis>
			<para>
				Initializes a <constant>SCAN</constant> structure for scanning by pointing the structure a <varname>buffer</varname> of given <varname>length</varname>, resetting intermmediate pointers and clearing the token <varname>class</varname> code.
				</para>
			</section -->
		</section>
	</chapter>
