<chapter id='firmware'>
	<title>
		Firmware 
		</title>
	<section id='firmware-intro'>
		<title>
			Introduction 
			</title>
		<para>
			An Intellon chipset consists of an integral <acronym>CPU</acronym>, <acronym>ROM</acronym> and proprietary circuitry. The <acronym>CPU</acronym> requires a minimum amount of external <acronym>SDRAM</acronym> to execute runtime software and store runtime configurtation parameters. The <productname>INT6000</productname> chipset also requires a minimum amount of external <acronym>NVRAM</acronym> in order to start. The <productname>INT6300</productname> can use external <acronym>NVRAM</acronym> in the same way as the <productname>INT6000</productname> or it can use a local host processor as surrogate <acronym>NVRAM</acronym>.			
			</para>
		<para>
			On startup, the SDRAM memory controller must be configured before runtime firmware and parameters are loaded. On the <productname>INT6000</productname>, runtime firmware and configuration parameters must be loaded from external <acronym>NVRAM</acronym>. On the <productname>INT6300</productname>, it may be loaded from external <acronym>NVRAM</acronym> or from a external host processor. Runtime firmware determines device capability. Runtime configuration parameters determine device network identity and personality.
			</para>
		<para>
			The following sections identify and describe firmware related components and discuss some of the routine actions required to manage them. Consult the Intellon <citetitle>HomePlug AV Hardware Technical Reference Manual</citetitle> and <citetitle>HomePlug AV Firmware Technical Reference Manual</citetitle> for more information.
			</para>
		</section>
	<section id="firmware-components" >
		<title>Firmware Components</title>
		<para>
			Device initialization involves the following components. They are described here and then referenced throughout the toolkit documentation. You may want to read and re-read this page. 
			</para>
		<section id="firmware-bootloader">
			<title>
				Bootloader 
				</title>
			<para>
				The <application>Bootloader</application> is permanent software burned into the chipset. The <productname>INT6000</productname> and <productname>INT6300</productname> both have a <application>Bootloader</application> program but they behave differently because the <productname>INT6000</productname> needs <acronym>NVRAM</acronym> and the <productname>INT6300</productname> does not. Neither the <productname>INT6000</productname> <application>Bootloader</application> nor the <productname>INT6300</productname> <application>Bootloader</application> can write to <acronym>NVRAM</acronym>.
				</para>
			<para>
				On startup,  the <productname>INT6000</productname> <application>Bootloader</application> attempts to load runtime firmware from <acronym>NVRAM</acronym> into <acronym>SDRAM</acronym>. If <acronym>NVRAM</acronym> is not available,  or the runtime firmware stored there cannot be loaded,  then the <productname>INT6000</productname> <application>Bootloader</application> cannot continue so the device cannot function.
				</para>
			<para>
				On startup,  the <productname>INT6300</productname> <application>Bootloader</application> attempts to load runtime firmware from <acronym>NVRAM</acronym> into <acronym>SDRAM</acronym>. If <acronym>NVRAM</acronym> is not available,  or the runtime firmware stored there cannot be loaded,  then <application>Bootloader</application> will request runtime firmware from the local host processor.
				</para>
			</section>
		<section id="firmware-softloader" >
			<title>
				Softloader 
				</title>
			<para>
				An optional program stored in <acronym>NVRAM</acronym> in place of runtime firmware. This program is used on the <productname>INT6000</productname> to support the Boot From Host operation, if needed. It is not used on the <productname>INT6300</productname> because the <productname>INT6300</productname> <application>Bootloader</application> now performs similar functions. The Softloader cannot write to <acronym>NVRAM</acronym>.
				</para>
			<para>
				On startup,  the <productname>INT6000</productname> <application>Bootloader</application> loads the <application>Softloader</application> from <acronym>NVRAM</acronym> into <acronym>SDRAM</acronym>,  as it would do with runtime firmware. The <application>Softloader</application> then requests the actual runtime firmware from local host. 
				</para>
			</section>
		<section id="firmware-memory-configuration" >
			<title>
				Memory Configuration Parameters
				</title>
			<para>
				A small block of information that describes the type, size and characteristics of the <acronym>SDRAM</acronym> available for the benefit of the <acronym>Bootloader</acronym>. On the INT6000, <acronym>SDRAM</acronym> configuration must be stored in <acronym>NVRAM</acronym>. On the INT6300, it may be stored in <acronym>NVRAM</acronym> or on the local host. The <productname>INT6300</productname> <application>Bootloader</application> attempts to read configuration information from <acronym>NVRAM</acronym> when it is present; otherwise, it requests that information from the local host using a VS_HST_ACTION message and so the host must store this information until it is requested.  
				</para>
			<para>
				There are two <acronym>SDRAM</acronym> configuration file formats. The first format is used by the <application>Windows Device Manager</application> and the <ulink url='int6k2.7.html'><application>int6k2</application></ulink> program and typically has a <filename>.config</filename> file extension. The second format is used by the <ulink url='int6k.7.html'><application>int6k</application></ulink> program and <ulink url='int6kf.7.html'><application>int6kf</application></ulink> program and typically has a <filename>.cfg</filename> file extension. The latter format is more robust and should eventually replace the format.
				</para>
			<para>
				The Windows Device Manager form consists of 64 hexadecimal ASCII characters. Files are at least 64 bytes but only the first 64 bytes are used. Files can be modified using a text editor. ASCII hex to binary conversion and checksum computation is needed on input. The <ulink url="config2cfg.7.html"><application>config2cfg</application></ulink> program can be used to convert this format to Linux Toolkit format. 
				</para>
			<para>
				The Linux Toolkit format consists of 32 binary bytes plus a 4 byte checksum. The file size is exactly 36 bytes. No conversion or checksum computation is needed on input. The <ulink url="chkcfg.7.html"><application>chkcfg</application></ulink> program can be used the validate this file format because it contains a checksum. 
				</para>
			<para>
				The <productname>INT6400</productname> chipset does not need a memory configuration parameter file because it has a different memory controller than earlier chipsets. <acronym>SDRAM</acronym> is now configured dynamically by an applets stored in the <filename>.nvm</filename> file.
				</para>
			</section>
		<section id="firmware-runtime" >
			<title>
				Runtime Firmware (MAC Software)
				</title>
			<para>
				The executable image that determines <productname>INT6000</productname> or <productname>INT6300</productname> capability and functionality. Runtime firmware refers to any executable image except the <link linkend="firmware-bootloader">Bootloader</link> which is considered to be boot firmware. Firmware files have a .nvm extension and can contain multiple firmware images. One of these images could be the parameter information block but Intellon currently distributes that as a seperate file. The <ulink url='chknvm.7.html'>chknvm</ulink> program can be used to detect obsolete or corrupt .nvm files. Runtime firmware can write to <acronym>NVRAM</acronym> and must be running in order to re-program the chipset. 
				</para>
			</section>
		<section id="firmware-configuration" >
			<title>
				Parameter Information Block (PIB)
				</title>
			<para>
				The configuration image that determines device network identity, functional capability and operational mode. The PIB structure often changes from one major firmware release to the next and often is not portable across major releases. Parameter information files have a <filename>.pib</filename> extension by convention and contain one parameter set. The <ulink url='chkpib.7.html'>chkpib</ulink> program can be used to detect obsolete or corrupt PIB files.
				</para>
			<para>
				Recent firmware releases support two <acronym>PIB</acronym> images in <acronym>NVRAM</acronym>: the Factory <acronym>PIB</acronym> and the User <acronym>PIB</acronym>. The Factory <acronym>PIB</acronym> is the first <acronym>PIB</acronym> image written to <acronym>NVRAM</acronym>. Once written, the Factory <acronym>PIB</acronym> cannot be changed without special software. The User <acronym>PIB</acronym> is created and over-written whenever the device needs to save new <acronym>PIB</acronym> parameters. Factory default values are restored by erasing the User <acronym>PIB</acronym> and rebooting the device. When a device reboots, it attempts to load the User <acronym>PIB</acronym> from <acronym>NVRAM</acronym>. Failing that, it attempts to load the Factory <acronym>PIB</acronym> from <acronym>NVRAM</acronym>. Failing that, it loads a Default <acronym>PIB</acronym> having minimum functionality. The loaded <acronym>PIB</acronym> becomes the Working <acronym>PIB</acronym> and determines runtime device identity and behavior. 
				</para>
			</section>
		</section>
	<section id='firmware-architecture'>
		<title>
			Architecture Overview 
			</title>
		<para>
			The following figure illustrates a hypothetical powerline network consisting of two devices. Each device has an <trademark>INT6300</trademark>  with optional dedicated <acronym>NVRAM</acronym> and an onboard processor with associated storage. The processor in each device is the local host for that device and the remote host for the other device. The processor storage is unspecified but it must be persistent. The two devices are connected via coax or powerline. The <acronym>NVRAM</acronym> is optional in this design because it uses the <trademark>INT6300</trademark>  chipset. 
			</para>
		<figure>
			<title>
				Simple Network
				</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref='SimpleNetwork.png' format='PNG' align='center' />
					</imageobject>
				</mediaobject>
			</figure>
		<para>
			The Boot Loader is permanent program that executes on startup. It detects the presence of <acronym>NVRAM</acronym> and attempts to read <acronym>SDRAM</acronym> configuration fro <acronym>NVRAM</acronym> then load and runtime the firmware image and <acronym>PIB</acronym> from <acronym>NVRAM</acronym>. On success, the Boot runtime firmware starts and the device assumes HomePlug AV compliant behavior. On failure, the Boot Loader requests <acronym>SDRAM</acronym> configruation, runtime firmware image and <acronym>PIB</acronym> from the local host. The local host must be prepared to respond to these requests. 
			</para>
		<para>
			On a system having no <acronym>NVRAM</acronym>, the Boot Loader will request SDRAM configuration information from the local host. Once that is received, the Boot Loader will request a firmware image and <acronym>PIB</acronym> from the local host. The local host determines which firmware image and <acronym>PIB</acronym> to download, manages the download sequence and starts firmware execution. 
			</para>
		<para>
			Intellon software, such as the Windows Device Manager, Linux Flash Utility and Embedded API all support the <emphasis>Boot from Host</emphasis> configuration.
			</para>
		<para>
			Once the firmware is running on the <trademark>INT6300</trademark> , a remote host can forward runtime firmware and <acronym>PIB</acronym> to the local host via the <trademark>INT6300</trademark>  firmware. The remote host might reside on another<trademark>INT6300</trademark>  device, as shown in the previous figure, or be located anywhere on the <trademark class='registered'>HomePlug</trademark> AV network. In either case, the operations described are the same. 
			</para>
		</section>
	<section id='firmware-bootload'>
		<title>
			Firmware Boot Process
			</title>
		<para>
			The <trademark>INT6300</trademark>  can boot HomePlug AV firmware from either dedicated <acronym>NVRAM</acronym> or a local host processor. This means that dedicated <acronym>NVRAM</acronym> in not necessary when an onboard processor having persistent storage is available. The absence of dedicated <acronym>NVRAM</acronym> and availability of an onboard host processor is called a <emphasis>Boot from Host</emphasis> configuration. 
			</para>
		<para>
			The Boot from Host configuration is of interest to customers who are committed to using a host processor in their <trademark>INT6300</trademark> based product and want to use it to eliminate the additional cost of dedicated <acronym>NVRAM</acronym> to store HomePlug AV firmware for <trademark>INT6300</trademark> devices. 
			</para>
		<para>
			The Boot from Host configuration supports three operations: <link linkend="firmware-upgrade">Upgrade Device</link>, <link linkend="firmware-upload">Update Local Host</link> and <link linkend="firmware-boot-int6000">Boot from Host</link>. Product designers must write host software to support all three operations as described later in this document. Intellon provides an Embedded Application Program Interface to assist product designers with this effort. Obtain a copy of the <citetitle>HomePlug AV Application Programming Interface User's Guide</citetitle> from Intellon Corporation,  Ocala FL USA for more information.
			</para>
		<para>
			Readers should not confuse the Boot from Host configuration with the <link linkend="firmware-boot-int6000">Boot from Host</link> operation. The former is a hardware configuration having an <trademark>INT6300</trademark>  with no dedicated <acronym>NVRAM</acronym> available. The latter is the process of downloading configuration information, firmware and <acronym>PIB</acronym> from the local host to the device and starting firmware execution on startup. 
			</para>
		<para>
			This discussion assumes that the reader is familiar with the following: 
			</para>
		<orderedlist spacing="compact">
			<listitem>
				<para>The distinction between a local and remote host</para>
				</listitem>
			<listitem>
				<para>
					The relationship between the INT6x00 H1, M1 and PHY interfaces 
					</para>
				</listitem>
			<listitem>
				<para>
					The structure of the following Intellon Management Message types: <constant>VS_HST_ACTION</constant>,  <constant>VS_SET_SDRAM</constant>, <constant>VS_WR_MOD</constant>, <constant>VS_WR_MEM</constant>, <constant>VS_RS_DEV</constant> and <constant>VS_ST_MAC</constant>.
					</para>
				</listitem>
			<listitem>
				<para>
					Hardware architecture covered in the <citetitle>INT6x00 Hardware Technical Reference Manual</citetitle> and the management message formats covered in the <citetitle>HomePlug AV Firmware Technical Reference Manual</citetitle>.
					</para>
				</listitem>
			</orderedlist>
		</section>

	<section id='firmware-boot-from-host'>
		<title>
			Boot from Host Configuration 
			</title>
		<para>
			The Boot from Host configuration requires a permanent connection between the <trademark>INT6300</trademark>  chipset and a local host having some type of persistent storage. In most cases, the <trademark>INT6300</trademark>  and local host are co-located, possibly on the same board, and act together as an integral unit. Essentially, the local host provides surrogate <acronym>NVRAM</acronym> for the device.
			</para>
		<para>
			The Boot from Host configuration lets the local host decide which runtime firmware image and <acronym>PIB</acronym> to download on startup or reset. This offers a considerable degree of product adaptability,  allowing different firmware and PIB combinations to be downloaded based on external factors. 
			</para>
		<para>
			In a Boot from Host configuration, the processor must act as local host while the device is booting but it can also act as remote host when upgrading other devices. The former is a design requirement and latter is a design option.
			</para>
		</section>
	<section id="bootload-rules">
		<title>
			Things to Remember
			</title>
		<para>
			The Boot from Host configuration offers design flexibility but that flexibility also increases the possibilities. Remember that the processes described here are based on simple rules that ultimatey dictate why each process step is needed. Readers may find it helpful to review these rules.
			</para>
		<orderedlist>
			<listitem>
				<para>
					<emphasis>The Softloader and Bootloader have limited vocabulary</emphasis>. 
					</para>
				<para>
					The <trademark>INT6000</trademark> Softloader recognizes only the <constant>VS_SW_VER</constant>, <constant>VS_ST_MAC</constant>, <constant>VS_RS_DEV</constant>, <constant>VS_WR_MOD</constant> and  messages. It does not recognize <constant>VS_WR_MEM</constant>. 
					</para>
				<para>
					The <trademark>INT6300</trademark> Bootloader recognizes only the <constant>VS_SW_VER</constant>, <constant>VS_WR_MEM</constant>, <constant>VS_ST_MAC</constant>, <constant>VS_RS_DEV</constant> and <constant>VS_SET_SDRAM</constant> messages. It does not recognize <constant>VS_WR_MOD</constant>.
					</para>
				<para>
					The <trademark>INT6400</trademark> Bootloader recognizes only the <constant>VS_SW_VER</constant>, <constant>VS_WR_MEM</constant>, <constant>VS_ST_MAC</constant>, <constant>VS_RS_DEV</constant> message. It recognizes <constant>VS_SET_SDRAM</constant> and responds to it but ignores it. It does not recognize <constant>VS_WR_MOD</constant>.
					</para>
				<para>
Runtime firmware must be loaded before doing anything else,  such as flashing <acronym>NVRAM</acronym>.
					</para>
		<table>
			<title>
				Softloader/Bootloader MMEs
				</title>
			<tgroup cols="4">
			<colspec colname='bootload-code'/>
			<colspec colname='bootload-name'/>
			<colspec colname='bootload-softloader'/>
			<colspec colname='bootload-bootloader'/>
			<colspec colname='bootload-firmware'/>
			<thead>
				<row>
					<entry>
						MME
						</entry> 
					<entry>
						NAME
						</entry> 
					<entry>
						INT6000 Softloader
						</entry> 
					<entry>
						INT6300 Bootloader
						</entry> 
					<entry>
						INT6400 Bootloader
						</entry> 
					</row>
				</thead>
			<tbody>
				<row>
					<entry>
						0xA000
						</entry>
					<entry>
						VS_SW_VER
						</entry>
					<entry>
						Yes
						</entry>
					<entry>
						Yes
						</entry>
					<entry>
						Yes
						</entry>
					</row>
				<row>
					<entry>
						0xA008
						</entry>
					<entry>
						VS_WR_MEM
						</entry>
					<entry>
						No
						</entry>
					<entry>
						Yes 
						</entry>
					<entry>
						Yes
						</entry>
					</row>
				<row>
					<entry>
						0xA00C
						</entry>
					<entry>
						VS_ST_MAC
						</entry>
					<entry>
						Yes
						</entry>
					<entry>
						Yes 
						</entry>
					<entry>
						Yes
						</entry>
					</row>
				<row>
					<entry>
						0xA01C
						</entry>
					<entry>
						VS_RS_DEV
						</entry>
					<entry>
						Yes
						</entry>
					<entry>
						Yes
						</entry>
					<entry>
						Yes
						</entry>
					</row>
				<row>
					<entry>
						0xA020
						</entry>
					<entry>
						VS_WR_MOD
						</entry>
					<entry>
						Yes
						</entry>
					<entry>
						No
						</entry>
					<entry>
						No
						</entry>
					</row>
				<row>
					<entry>
						0xA05C
						</entry>
					<entry>
						VS_SDRAM
						</entry>
					<entry>
						No
						</entry>
					<entry>
						Yes
						</entry>
					<entry>
						Not Really
						</entry>
					</row>
				</tbody>
			</tgroup>
			</table>
				</listitem>
			<listitem>
				<para>
					<emphasis>The Softloader,  Bootloader and runtime firmware treat some MMEs differently</emphasis> because each is a different program. 
					</para>
				</listitem>
			<listitem>
				<para>
					<emphasis>The local host is surrogate NVRAM</emphasis>. When dedicated NVRAM is not available to a device, the device will request firmware and parameter storage services from the local host using <constant>VS_HST_ACTION</constant> messages. The local host must be programmed to detect and respond to these messages or the firmware will appear to hang. See program <link linkend='program-int6khost'>int6khost</link> to demonstrate and experiment with this iteraction.
					</para>
				</listitem>
			<listitem>
				<para>
					<emphasis>Only runtime firmware can commit changes to NVRAM</emphasis>. Runtime firmware must be executing in order to write <acronym>NVRAM</acronym> or upload to the local host. The Softloader and Bootloader cannot perform either operation.
					</para>
				</listitem>
			<listitem>
				<para>
					<emphasis>All <acronym>PIB</acronym> changes must be committed to NVRAM</emphasis>. There are several things that can cause <acronym>PIB</acronym> changes. When a <acronym>PIB</acronym> change is needed,  the Working <acronym>PIB</acronym> is copied to a scratch area and modified there. The Scratch <acronym>PIB</acronym> must then be written to <acronym>NVRAM</acronym> or sent to the local host for storage. The device then resets causing the stored <acronym>PIB</acronym> to replace the Working <acronym>PIB</acronym>. If a freshly downloaded <acronym>PIB</acronym> changes for any reason then the cycle will repeat, automatically. 
					</para>
				</listitem>
			<listitem>
				<para>
					<emphasis>Runtime firmware modifies the PIB after joining and before leaving an AVLN</emphasis>. This will cause a device reset in each case. If the device is using the local host for persistent storage, runtime firmware will send the associated <constant>VS_HST_ACTION</constant> messages to the host and the host will send the associated <constant>VS_RD_MOD</constant> and <constant>VS_RS_DEV</constant> messages as per <link linkend="firmware-upload">Update Local Host</link>.
					</para>
				</listitem>
			<listitem>
				<para>
					<emphasis>The Boot from Host process differs on the <trademark>INT6000</trademark>,  <trademark>INT6300</trademark> and <trademark>INT6400</trademark>.</emphasis> The <link linkend="firmware-upgrade">Upgrade Device</link> and <link linkend="firmware-upload">Update Local Host</link> operations are the same for all three chipsets because they are firmware driven. The <link linkend="firmware-boot-int6000">Boot from Host</link> differs on each chipset because it is <application>Softloader</application> driven on the <trademark>INT6000</trademark> and <application>Bootloader</application> driven on the <trademark>INT6300</trademark> and <trademark>INT6400</trademark>. The <application>Bootloader</application> on the latter two chipsets is identical except for the initialization of SDRAM parameters. 
					</para>
				</listitem>
			</orderedlist>
		</section>
	<section id="firmware-caveats">
		<title>
			Caveats
			</title>
		<para>
			With the addition of <application>Push Button Encryption</application>, and other planned features, runtime firmware can now modify the PIB. Consequently, host applications must not assume that the <acronym>PIB</acronym> has not changed since it was last downloaded. Intellon strongly recommends that applications always perform a <emphasis>read-modify-write</emphasis> when making <acronym>PIB</acronym> modifications. Failure to do so can result in infinite reset loops caused when a device modifies the <acronym>PIB</acronym> that has just been downloaded. 
			</para>
		<para>
			As one example, recent <acronym>PIB</acronym>s contain a network membership bit to indicate that the device has successfully joined the network associated with the current <acronym>NMK</acronym>. If the firmware detects the network and find that the membership bit is clear then it will join the network and set the bit. The firmware will then attempt to preserve the change by sending a <constant>VS_HOST_ACTION</constant> message to the local host. If the host application does not upload and store the changed <acronym>PIB</acronym> (as the device requested) before resetting the device then the original <acronym>PIB</acronym> will be downloaded again,  after reset, and the process will repeat. Of course, a similar situation will occur when the device leaves the network and again when it joins another network.
			</para>
		<para>
			It is important to use the right Boot from Host sequence for each type of Intellon device. This means that you should query the device using a VS_SW_VER message beforehand to determine or confirm the device type. Unfortunately, the <trademark>INT6300</trademark> <application>Bootloader</application> incorrectly identifies the device as an INT6000 and so you must consider the software that is reporting the hardware type. If the <application>Bootloader</application> identifies the device as an <trademark>INT6000</trademark> then the device is actually an <trademark>INT6300</trademark>. The table below illustrates what is reported by various firmware on each type of hardware platform.
			</para>
		<table>
			<title>
				Device Identification
				</title>
			<tgroup cols="4">
			<colspec colname='bootload-platform'/>
			<colspec colname='bootload-softloader'/>
			<colspec colname='bootload-bootloader'/>
			<colspec colname='bootload-firmware'/>
			<thead>
				<row>
					<entry>
						Platform
						</entry> 
					<entry>
						Softloader
						</entry> 
					<entry>
						Bootloader
						</entry> 
					<entry>
						Firmware
						</entry> 
					</row>
				</thead>
			<tbody>
				<row>
					<entry>
						INT6000A1
						</entry>
					<entry>
						INT6000A1
						</entry>
					<entry>
						&nbsp;
						</entry>
					<entry>
						INT6000A1
						</entry>
					</row>
				<row>
					<entry>
						INT6300A0
						</entry>
					<entry>
						&nbsp;
						</entry>
					<entry>
						INT6000A1
						</entry>
					<entry>
						INT6300A0
						</entry>
					</row>
				<row>
					<entry>
						INT6400A0
						</entry>
					<entry>
						&nbsp;
						</entry>
					<entry>
						INT6400A0
						</entry>
					<entry>
						INT6400A0
						</entry>
					</row>
				<row>
					<entry>
						INT6400A1
						</entry>
					<entry>
						&nbsp;
						</entry>
					<entry>
						INT6400A0
						</entry>
					<entry>
						INT6400A0
						</entry>
					</row>
				</tbody>
			</tgroup>
			</table>
		</section>
	<section id='firmware-upgrade'>
		<title>
			Upgrade Device (INT6000/INT6300/INT6400)
			</title>
		<para>
			The Upgrade Device operation downloads firmware and/or <acronym>PIB</acronym> from a remote host to an Intellon device for permanent storage and immediate execution. The device determines where and how it will store the information based on the availability of onboard <acronym>NVRAM</acronym>. If the device has dedicated <acronym>NVRAM</acronym> then it will store the firmware and <acronym>PIB</acronym> there and reset itself; otherwise, it will hand the firmware and <acronym>PIB</acronym> to the local host for storage and the local host will reset the device. The reset ensures that new formware and <acronym>PIB</acronym> take immediate effect once they are saved. This operation requires custom software on the remote host and Intellon firmware on the device. 
			</para>
		<figure>
			<title>
				Upgrade Device (INT6000/INT6300/INT6400)
				</title>
<programlisting><![CDATA[
        REMOTE-HOST                        INT6300/INT6400
        [01] |-------- VS_WR_MOD.REQ ------------>| [01]
        [01] |<------- VS_WR_MOD.CNF -------------| [01]
        [01] |----------------------------------->| [01]
        [01] |<-----------------------------------| [01]
        [01] |----------------------------------->| [01]
        [01] |<-----------------------------------| [01]
             |                                    |
        [02] |-------- VS_WR_MOD.REQ ------------>| [02]
        [02] |<------- VS_WR_MOD.CNF -------------| [02]
        [02] |----------------------------------->| [02]
        [02] |<-----------------------------------| [02]
        [02] |----------------------------------->| [02]
        [02] |<-----------------------------------| [02]
             |                                    |
        [03] |-------- VS_MOD_NVM.REQ ----------->| [04]
        [05] |<------- VS_MOD_NVM.CNF ------------| [04]
             |                                    | [06]
]]></programlisting>
			</figure>
		<orderedlist>
			<listitem>
				<para>
					Optionally, the remote host writes firmware to the device by sending a series of VS_WR_MOD.REQ messages and waiting for a VS_WR_MOD.CNF message after each one. The message MODULEID field is set to 0x01 for this operation. 
					</para>
				</listitem>
			<listitem>
				<para>
					Optionally, the remote host writes the <acronym>PIB</acronym> to the device by sending a series of VS_WR_MOD.REQ messages and waiting for a VS_WR_MOD.CNF message after each one. The message MODULEID field is set to 0x02 for this operation. 
					</para>
				</listitem>
			<listitem>
				<para>
					The remote host commits the firmware and/or <acronym>PIB</acronym> to persistent storage by sending a VS_MOD_NVM.REQ message and waiting for a VS_MOD_NVM.CNF message. 
					</para>
				</listitem>
			<listitem>
				<para>
					The device received the VS_MOD_NVM.REQ and sends a VS_MOD_NVM.CNF message to the remote host. 
					</para>
				</listitem>
			<listitem>
				<para>
					The remote host receives the VS_MOD_NVM.CNF and proceeds with other activity. The remote host does not know or care that the device may not have dedicated <acronym>NVRAM</acronym> available.
					</para>
				</listitem>
			<listitem>
				<para>
					The device determines where and how to store the information. If dedicated <acronym>NVRAM</acronym> is available, the device writes the downloaded firmware and <acronym>PIB</acronym> to <acronym>NVRAM</acronym> and performs a software reset that results in a normal <emphasis>Boot from Flash</emphasis> operation. If no dedicated <acronym>NVRAM</acronym> is available, the device initiates an <link linkend='firmware-upload'>Update Local Host</link> operation.
					</para>
				</listitem>
			</orderedlist>
		<para>
			The device does not notify the remote host when the upgrade operation completes. It is therefore incumbent on the remote host to determine ultimate success or failure by polling the device, possiby using a VS_SW_VER.REQ message, until a response is received. The complete upgrade operation can take from 20 seconds to 45 seconds depending on device configuration.
			</para>
		</section>
	<section id='firmware-upload'>
		<title>
			Update Local Host (INT6000/INT6300/INT6400)
			</title>
		<para>
			The Update Local Host operation transfers a firmware image and/or <acronym>PIB</acronym>image from the device to the local host for permanent storage. After the firmware and <acronym>PIB</acronym> are stored, the local host will reset the device and the device will retrieve the firmware and <acronym>PIB</acronym> using a <link linkend="firmware-boot-int6000">Boot from Host</link> operation, described in the next section.
			</para>
		<para>
			The firmware may initiate this operation after a remote host has downloaded new firmware or <acronym>PIB</acronym> and issued a VS_MOD_NVM.REQ to the device,  the device has been asked to restore factory default settings or the firmware has dynamically altered the runtime <acronym>PIB</acronym> in some way. Consequently, the device will be reset by the host in each case.
			</para>
		<para>
			The device initiates this operation to complete an Upgrade Device operation when the device has no dedicated <acronym>NVRAM</acronym> onboard. This operation requires running Intellon firmware on the device and custom software on the local host.
			</para>
		<figure>
			<title>
				Update Local Host (INT6000/INT6300/INT6400)
				</title>
<programlisting><![CDATA[
      INT6300/INT6400                           LOCAL-HOST
        [01] |-------- VS_HST_ACTION.IND -------->| [01]
        [03] |<------- VS_HST_ACTION.RSP ---------| [02]
             |                                    |
        [04] |<------- VS_RD_MOD.REQ -------------| [04]
        [04] |-------- VS_RD_MOD.CNF ------------>| [04]
        [04] |<-----------------------------------| [04]
        [04] |----------------------------------->| [04]
             |                                    |
        [05] |<------- VS_RD_MOD.REQ -------------| [05]
        [05] |-------- VS_RD_MOD.CNF ------------>| [05]
        [05] |<-----------------------------------| [05]
        [05] |----------------------------------->| [05]
             |                                    |
        [06] |<------- VS_RS_DEV.REQ -------------| [06]
        [07] |-------- VS_RS_DEV.CNF ------------>| [07]
]]></programlisting>
			</figure>
		<orderedlist>
			<listitem>
				<para>
					The <application>runtime firmware</application> initiates this operation by broadcasting VS_HST_ACTION.IND messages every 500 milliseconds. The HOST_ACTION_REQ field of the message can be either 0x01, 0x02 or 0x03 to indicate that a firmware image, a <acronym>PIB</acronym> image or both are ready for upload by the local host. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host sends a VS_HST_ACTION.RSP message to the device to indicate the ability and willingness to upload the information. The MSTATUS field is set to 0x00 for affirmative and 0x01 for negative. 
					</para>
				</listitem>
			<listitem>
				<para>
					Assuming an affirmative response, the device stops broadcasting and will wait indefinitely for local host action. 
					</para>
				</listitem>
			<listitem>
				<para>
					Optionally, the local host reads the firmware image from the device by sending a series of VS_RD_MOD.REQ messages to the device and waiting for a VS_RD_MOD.CNF message after each one. The message MODULEID field is set to 0x01 for this operation. 
					</para>
				</listitem>
			<listitem>
				<para>
					Optionally, the local host reads the <acronym>PIB</acronym> from the device by sending a series of VS_RD_MOD.REQ messages to the device and waiting for a VS_RD_MOD.CNF message after each one. The message MODULEID field is set to 0x02 for this operation. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host sends a VS_RS_DEV.REQ message to the device to initiate a firmware reboot. 
					</para>
				</listitem>
			<listitem>
				<para>
					The device sends a VS_RS_DEV.CNF to the host and performs a software reset. This forces a <link linkend='firmware-boot-int6000'>Boot from Host</link>.
					</para>
				</listitem>
			</orderedlist>
		</section>
	<section id='firmware-boot-int6000'>
		<title>
			Boot from Host (INT6000)
			</title>
		<para>
			The Boot from Host operation downloads a firmware image and <acronym>PIB</acronym> image from the local host and starts firmware execution. The process is initiated by the <trademark>INT6000</trademark> <application>Bootloader</application> following a device reset. The <application>Bootloader</application> passes control to the <trademark>INT6000</trademark> <application>Softloader</application> to negotiate with the local host. The process thererfore requires <application>Softloader</application> aware software running on the local host in order to complete.
			</para>
		<para>
			The device does not have a unique hardware address until the firmware starts and assigns one. Until that time, the <application>Softloader</application> accepts messages addressed to 00:B0:52:00:00:01. In addition, the <application>Softloader</application> does not know the hardware address of the local host and so it addresses VS_HST_ACTION messages to FF:FF:FF:FF:FF:FF; however, these messages are not forwarded over powerline.
			</para>
		<figure>
			<title>
				Boot from Host (INT6000)
				</title>
<programlisting><![CDATA[
       INT6300/INT6400                        LOCAL-HOST
        [01] |                                    |
             |                                    |
        [02] |-------- VS_HST_ACTION.IND -------->| [03]
        [05] |<------- VS_HST_ACTION.RSP ---------| [04]
             |                                    |
        [07] |<------- VS_WR_MOD.REQ -------------| [07]
        [07] |-------- VS_WR_MOD.CNF ------------>| [07]
        [07] |<-----------------------------------| [07]
        [07] |----------------------------------->| [07]
             |                                    |
        [08] |<------- VS_WR_MOD.REQ -------------| [08]
        [08] |-------- VS_WR_MOD.CNF ------------>| [08]
        [08] |<-----------------------------------| [08]
        [08] |----------------------------------->| [08]
              |                                    |
        [10] |<------- VS_ST_MAC.REQ -------------| [09]
        [11] |-------- VS_ST_MAC.CNF ------------>| [12]
 ]]></programlisting>
			</figure>
		<orderedlist>
			<listitem>
				<para>
					The <trademark>INT6000</trademark> <application>Bootloader</application> automatically starts after device reset. It reads the <application>Softloader</application> from <acronym>NVRAM</acronym>,  writes it into <acronym>SDRAM</acronym> and starts execution. The <application>Softloader</application> then manages the Boot from Host process.
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Softloader</application> broadcasts a VS_HST_ACTION.IND message every 500 milliseconds to request the download of runtime firmware and <acronym>PIB</acronym>. The HOST_ACTION_REQ field of the message is 0x00 in this case. The message source address if 00:B0:52:00:00:01 as explained above. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host receives the VS_HST_ACTION.IND message and inspects the HOST_ACTION_REQ field to determine action requested. It may then elect to service the request or ignore it. On a single-host system, the host must service the request or the device will not start. On a multi-host system,  one of the hosts must elect to service the request or the device will not start.
					</para>
				</listitem>
			<listitem>
				<para>
					The local host sends a VS_HST_ACTION.RSP message to the device to indicate the ability and willingness to service the request. The MSTATUS field is set to 0x00 for affirmative and 0x01 for negative. 
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Softloader</application> receives the VS_HST_ACTION.RSP from the host and inspects the MSTATUS field. On affirmative status, the <application>Softloader</application> stops sending VS_HST_ACTION messages and waits indefinitely for the firmware image and <acronym>PIB</acronym>. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host determines which firmware image and <acronym>PIB</acronym> to download. In some cases there may be no choice. In other cases, there may be a choice between default and custom software or between current and upgraded software. This is a principle design issue to consider. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host downloads a firmware image to the device by sending VS_WR_MOD.REQ messages to the device and waiting for a VS_WR_MEM.CNF messages from the device after each request. Each message contains an image segment,  the memory offset, the segment length and the checksum used to monitor and manage download progress. If a single transaction fails, the local host should detect it and repeat it. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host downloads a <acronym>PIB</acronym> to the device by sending VS_WR_MOD.REQ messages to the device and waiting for a VS_WR_MEM.CNF message from the device after each request. Each message contains an image segement,  the  memory offset, the segment length and the checksum used to monitor and manage download progress. If a single transaction fails, the local host should detect it and repeat it. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host starts execution of the downloaded firmware by sending a VS_ST_MAC.REQ message to the device. The message contains the start address for the firmware. 
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Softloader</application> receives the VS_ST_MAC.REQ from the local host, validates the content.
					</para>
				</listitem>
			<listitem>
					<para>The <application>Softloader</application> sends a VS_ST_MAC.CNF message to the local host to indicate an ability or willingness to start execution. Assuming an ability and willingness, the <application>Softloader</application> immediately starts firmware execution which relinquishes device control to the firmware. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host receives the VS_ST_MAC.CNF message from the device, inspects the MSTATUS field and acts accordingly. Assuming an affirmative status, this process terminates. 
					</para>
				</listitem>
			</orderedlist>
		</section>
	<section id='firmware-boot-int6300'>
		<title>
			Boot from Host (INT6300)
			</title>
		<para>
			The Boot from Host operation downloads <acronym>SDRAM</acronym> configuration information, a firmware image and a <acronym>PIB</acronym> image from a local host and starts firmware execution. This process is initiated by the <trademark>INT6300</trademark>  <application>Bootloader</application> after the reset of a device having no <acronym>NVRAM</acronym>, blank <acronym>NVRAM</acronym> or corrupted <acronym>NVRAM</acronym>. The process requires <application>Bootloader</application> aware software running on the local host in order to complete.
			</para>
		<para>
			The <trademark>INT6300</trademark>  Boot from Host process is similar to the <trademark>INT6000</trademark> Boot from Host process but it involves an extra stage to download <acronym>SDRAM</acronym> configuration parameters and uses VS_WR_MEM messages to download firmware and <acronym>PIB</acronym> instead of VS_WR_MOD messages. The VS_WR_MEM messages write directy to <acronym>SDRAM</acronym> and are needed to obtain a staring firmware image sunning. Once the firmware is running, it can be used to write a firmware image and PIB to <acronym>NVRAM</acronym>.
			</para>
		<para>
			The device does not have a unique hardware address until the firmware starts and assigns one read from the PIB. Until that time, the <application>Bootloader</application> will accept messages addressed to 00:B0:52:00:00:01. In addition, the <application>Bootloader</application> does not know the hardware address of the local host and so it addresses all <constant>VS_HST_ACTION</constant> messages to FF:FF:FF:FF:FF:FF; however, these messages are not transmitted over the powerline.
			</para>
		<figure>
			<title>
				Boot from Host (INT6300)
				</title>
<programlisting><![CDATA[
         INT6300                             LOCAL-HOST
        [01] |                                    |
             |                                    |
        [02] |-------- VS_HST_ACTION.IND -------->| [03]
        [05] |<------- VS_HST_ACTION.RSP ---------| [04]
             |                                    |
        [07] |<------- VS_SET_SDRAM.REQ ----------| [06]
        [07] |-------- VS_SET_SDRAM.CNF --------->| [08]
             |                                    |
             |                                    | [09]
             |                                    |
        [10] |<------- VS_WR_MEM.REQ -------------| [10]
        [10] |-------- VS_WR_MEM.CNF ------------>| [10]
        [10] |<-----------------------------------| [10]
        [10] |----------------------------------->| [10]
             |                                    |
        [11] |<------- VS_WR_MEM.REQ -------------| [11]
        [11] |-------- VS_WR_MEM.CNF ------------>| [11]
        [11] |<-----------------------------------| [11]
        [11] |----------------------------------->| [11]
             |                                    |
        [13] |<------- VS_ST_MAC.REQ -------------| [12]
        [14] |-------- VS_ST_MAC.CNF ------------>| [15]
             |                                    |
 ]]></programlisting>
			</figure>
		<orderedlist>
			<listitem>
				<para>
					The <application>Bootloader</application> automatically starts after device reset and attempts to read the runtime firmware image from <acronym>NVRAM</acronym>, write it into <acronym>SDRAM</acronym> and start execution. If it succeeds then normal operation begins and no futher action is required. If it fails, for any reason, then the <application>Bootloader</application> starts the Boot from Host process.
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> broadcasts a VS_HST_ACTION.IND message every 10 seconds to request <acronym>SDRAM</acronym> parameters. The HOST_ACTION_REQ field is 0x04 to indicate that <acronym>SDRAM</acronym> parameters are required. The message source address is 00:B0:52:00:00:01 as explained above.
					</para>
				</listitem>
			<listitem>
				<para>
					The host receives the VS_HST_ACTION.IND message and inspects the HOST_ACTION_REQ field to determine the action requested. On a single-host system,  the local host must elect to service the request or the device will not start. On a multi-host system,  one of the hosts must elect to service the request of the device will not start.
					</para>
				</listitem>
			<listitem>
				<para>
					The host sends a VS_HST_ACTION.RSP message to the device to indicate an ability and willingness to service the request. The MSTATUS field is set to 0x00 for affirmative and 0x01 for negative. 
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> receives the VS_HST_ACTION.RSP from the host and inspects the MSTATUS field. On affirmative response, the <application>Bootloader</application> stops broadcasting VS_HST_ACTION messages and waits indefinitely for <acronym>SDRAM</acronym> configuration information from the host. 
					</para>
				</listitem>
			<listitem>
				<para>
					The host sends a VS_SET_SDRAM.REQ message to the device containing an SDRAM configuration block and the block checksum. 
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> receives the VS_SET_SDRAM.REQ, validates the content, initializes <acronym>SDRAM</acronym> parameters and sends a VS_SET_SDRAM.CNF message to the servicing host to indicate either success or failure. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host receives the VS_SET_SDRAM.CNF and inspects the MSTATUS field for success or failure. Assuming success, the local host waits indefinitely for further requests from the device. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host determines which firmware image and <acronym>PIB</acronym> image to download. In some cases there may be no choice. In other cases, there may be a choice between default and custom software or between current and upgraded software. This is a principle design issue to consider. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host downloads the firmware image to the device by sending VS_WR_MEM.REQ messages to the device and waiting for a VS_WR_MEM.CNF messages from the device after each request. Each message contains an image segment,  the memory offset, the segment length and the checksum used to monitor and manage download progress. It a single transaction fails, the local host should detect it and repeat it.
					</para>
				</listitem>
			<listitem>
				<para>
					The local host downloads a <acronym>PIB</acronym> image to the device by sending VS_WR_MEM.REQ messages to the device and waiting for a VS_WR_MEM.CNF message from the device after each request. Each message contains an image segment,  the memory offset, the segment length and the checksum used to monitor and manage download progress. If a single transaction fails, the local host should detect it and repeat it. 
					</para>
				</listitem>
			<listitem>
				<para>
					The local host starts firmware execution by sending a VS_ST_MAC.REQ message to the device. The message contains the firmware start address.  
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> receives the VS_ST_MAC.REQ from the local host, validates the content.
					</para>
				</listitem>
			<listitem>
				<para>The device sends a VS_ST_MAC.CNF message to indicate an ability or willingness to start firmware execution. The device immediately starts firmware execution which relinquishes device control to the firmware. It can take 5 to 10 seconds for the firmware to start.  
					</para>
				</listitem>
			<listitem>
				<para>
					The host receives the VS_ST_MAC.CNF message from the device, inspects the MSTATUS field and acts accordingly. An afffirmative indication means that the firmware will start executing on the device in 5 to 10 seconds. Once the firmware starts,  future VS_HST_ACTION message will contain the unique hardware address for the device.
					</para>
				</listitem>
			</orderedlist>
		</section>
	<section id='firmware-boot-int6400'>
		<title>
			Boot from Host (INT6400)
			</title>
		<para>
			The Boot from Host operation downloads and executes a memory configuration applet then downloads runtime firmware and parameters from a local host and starts firmware execution. This process is initiated by the <trademark>INT6400</trademark>  <application>Bootloader</application> after reset on a device having no <acronym>NVRAM</acronym>, blank <acronym>NVRAM</acronym> or corrupted <acronym>NVRAM</acronym>. The process requires <application>Bootloader</application> aware software running on the local host in order to complete.
			</para>
		<para>
			The <trademark>INT6400</trademark>  Boot from Host process is similar to the <trademark>INT6300</trademark> Boot from Host process but it downloads and executes an SDRAM applet instead of downloading SDRAM parameters. The applet is downloaded and executed using the same mechanism as runtime firmware. The applet executes and returns to the <application>Bootloader</application> when done. The <application>Bootloader</application> then continues to drive the boot process.
			</para>
		<para>
			The device does not have a unique hardware address until the firmware starts and assigns one read from the PIB. Until that time, the <application>Bootloader</application> will accept messages addressed to 00:B0:52:00:00:01. In addition, the <application>Bootloader</application> does not know the hardware address of the local host and so it addresses all <constant>VS_HST_ACTION</constant> messages to FF:FF:FF:FF:FF:FF; however, these messages are not transmitted over the powerline.
			</para>
		<figure>
			<title>
				Boot from Host (INT6400)
				</title>
<programlisting><![CDATA[
         INT6400                             LOCAL-HOST
        [01] |                                    |
             |                                    |
        [02] |-------- VS_HST_ACTION.IND -------->| [03]
        [05] |<------- VS_HST_ACTION.RSP ---------| [04]
             |                                    |
        [06] |<------- VS_WR_MEM.REQ -------------| [06]
        [06] |-------- VS_WR_MEM.CNF ------------>| [06]
        [06] |<-----------------------------------| [06]
        [06] |----------------------------------->| [06]
             |                                    |
        [08] |<------- VS_ST_MAC.REQ -------------| [07]
        [09] |-------- VS_ST_MAC.CNF ------------>| [10]
             |                                    |
        [11] |                                    |
             |                                    |
        [12] |-------- VS_HST_ACTION.IND -------->| [13]
        [15] |<------- VS_HST_ACTION.RSP ---------| [14]
             |                                    |
             |                                    | [16]
             |                                    |
        [17] |<------- VS_WR_MEM.REQ -------------| [17]
        [17] |-------- VS_WR_MEM.CNF ------------>| [17]
        [17] |<-----------------------------------| [17]
        [17] |----------------------------------->| [17]
             |                                    |
        [18] |<------- VS_WR_MEM.REQ -------------| [18]
        [18] |-------- VS_WR_MEM.CNF ------------>| [18]
        [18] |<-----------------------------------| [18]
        [18] |----------------------------------->| [18]
             |                                    |
        [20] |<------- VS_ST_MAC.REQ -------------| [19]
        [21] |-------- VS_ST_MAC.CNF ------------>| [22]
             |                                    |
 ]]></programlisting>
			</figure>
		<orderedlist>
			<listitem>
				<para>
					The <application>Bootloader</application> automatically starts after device reset and attempts to read the runtime firmware image from <acronym>NVRAM</acronym>, write it into <acronym>SDRAM</acronym> and start execution. If it succeeds then normal operation begins and no futher action is required. If it fails, for any reason, then the <application>Bootloader</application> initiates a Boot from Host sequence.
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> broadcasts a <constant>VS_HST_ACTION.IND</constant> message every 500 milliseconds to request memory configuration. The message destination address is <constant>FF:FF:FF:FF:FF:FF</constant> and source address is <constant>00:B0:52:00:00:01</constant> as explained above. The <varname>HOST_ACTION_REQ</varname> field is set to 0x04.
					</para>
				</listitem>
			<listitem>
				<para>
					The host receives the <constant>VS_HST_ACTION.IND</constant> message and inspects the <varname>HOST_ACTION_REQ</varname> field to determine the requested action. On a single-host system, the lone host must service the request or the device will not start. On a multi-host system, one host must elect to service the request of the device will not start.
					</para>
				</listitem>
			<listitem>
				<para>
					The host sends a <constant>VS_HST_ACTION.RSP</constant> message to the device to indicate the ability and willingness to service the request. The message destination address is <constant>00:B0:52:00:00:01</constant> and the source address is that of the host interface. The <varname>MSTATUS</varname> field is set to <constant>0x00</constant> for affirmative and <constant>0x01</constant> for negative. 
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> receives the <constant>VS_HST_ACTION.RSP</constant> from the host and inspects the <varname>MSTATUS</varname> field. On affirmative response, the <application>Bootloader</application> stops broadcasting <constant>VS_HST_ACTION.IND</constant> messages and waits indefinitely for the host to download the memory control applet and start execution. 
					</para>
				</listitem>
			<listitem>
				<para>
					The host downloads the memory control applet to the device by sending <constant>VS_WR_MEM.REQ</constant> messages to the device and waiting for a <constant>VS_WR_MEM.CNF</constant> message from the device after each one. Each message contains an image segment and the segment memory offset, length and checksum. These values are used to monitor and manage download progress. If a transaction fails, the host can detect it and should repeat it.
					</para>
				</listitem>
			<listitem>
				<para>
					The host starts execution of the memory control applet by sending a <constant>VS_ST_MAC.REQ</constant> message to the device. The message contains the applet load address, length, checksum and start address. These values are often obtained from an NVM file image header.

					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> receives the <constant>VS_ST_MAC.REQ</constant> from the host and validates the contents.					
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> sends a <constant>VS_ST_MAC.CNF</constant> message to the host indicating the ability and willingness to start applet execution. The <varname>MSTATUS</varname> field is set to <constant>0x00</constant> for affirmative and <constant>0x01</constant> for negative.
					</para>
				</listitem>
			<listitem>
				<para>
					The host receives the <constant>VS_ST_MAC.CNF</constant> message from the device and evaluates the <varname>MSTATUS</varname> field. On affirmative,  the host waits for further requests from the device. On negative,  the host may attempt another start or another download followed by a start or attempt to alert a human.
					</para>
				</listitem>
			<listitem>
				<para>
 					The <application>Bootloader</application> starts applet execution. The applet configures memory, runs to completion and returns to the Bootloader.		
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> broadcasts a <constant>VS_HST_ACTION.IND</constant> message every 500 milliseconds to request runtime firmware and parameter download. The message destination address is <constant>FF:FF:FF:FF:FF:FF</constant> and source address is <constant>00:B0:52:00:00:01</constant> as explained above. The <varname>HOST_ACTION_REQ</varname> field is set to <constant>0x00</constant>. 
					</para>
				</listitem>
			<listitem>
				<para>
					The host receives the <constant>VS_HST_ACTION.IND</constant> message and inspects the <varname>HOST_ACTION_REQ</varname> field to determine the requested action. On a single-host system,  the lone host must service the request or the device will not start. On a multi-host system, one host must elect to service the request of the device will not start.
					</para>
				</listitem>
			<listitem>
				<para>
					The host sends a <constant>VS_HST_ACTION.RSP</constant> message to the device to indicate the ability and willingness to service the request. The <varname>MSTATUS</varname> field is set to <constant>0x00</constant> for affirmative and <constant>0x01</constant> for negative. 
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> receives the <constant>VS_HST_ACTION.RSP</constant> from the host and inspects the <varname>MSTATUS</varname> field. On affirmative response, the <application>Bootloader</application> stops broadcasting <constant>VS_HST_ACTION.IND</constant> messages and waits indefinitely for the host to download the runtime firmware and parameters and start execution. 
					</para>
				</listitem>
			<listitem>
				<para>
					The host determines which firmware and parameter image to download. In some cases there may be no choice. In other cases, there may be a choice between default and custom images or between current and upgraded images. This is a principle design issue to consider. 
					</para>
				</listitem>
			<listitem>
				<para>
					The host downloads the firmware image to the device by sending <constant>VS_WR_MEM.REQ</constant> messages to the device and waiting for a <constant>VS_WR_MEM.CNF</constant> message from the device after each one. Each message contains an image segment and the segment memory offset, length and checksum. These values are used to monitor and manage download progress. If a transaction fails, the local host can detect it and should repeat it.
					</para>
				</listitem>
			<listitem>
				<para>
					The host downloads the parameter block to the device by sending <constant>VS_WR_MEM.REQ</constant> messages to the device and waiting for a <constant>VS_WR_MEM.CNF</constant> message from the device after each one. Each message contains an image segment and the segment memory offset, length and checksum. These values are used to monitor and manage download progress. If a transaction fails, the local host can detect it and should repeat it. 
					</para>
				</listitem>
			<listitem>
				<para>
					The host starts runtime firmware execution by sending a <constant>VS_ST_MAC.REQ</constant> message to the device. The message contains the firmware load address, length, checksum and start address. These values are often obtained from an NVM file image header.
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> receives the <constant>VS_ST_MAC.REQ</constant> from the host and validates the content.
					</para>
				</listitem>
			<listitem>
				<para>
					The <application>Bootloader</application> sends a <constant>VS_ST_MAC.CNF</constant> message to indicate the ability or willingness to start firmware execution.   
					</para>
				</listitem>
			<listitem>
				<para>
					The host receives the <constant>VS_ST_MAC.CNF</constant> message from the device, inspects the <varname>MSTATUS</varname> field and acts accordingly. 
					</para>
				</listitem>
			<listitem>
				<para>
 					The <application>Bootloader</application> starts runtime firmware execution. The firmware reads and validates the parameter block then assumes full control of the device. It can take several seconds for firmware start to be evident. Once the firmware starts,  any future <constant>VS_HST_ACTION</constant> messages will contain the unique hardware address for the device.
					</para>
				</listitem>
			</orderedlist>
		</section>

	</chapter>
